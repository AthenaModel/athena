<manpage {athena(n)} "Athena Scenario Type">

<section SYNOPSIS>

<pre>
package require athena <version>
namespace import ::athena::*
</pre>

<itemlist>

<section DESCRIPTION>

athena(n) is the primary public interface for the athena(n) package.
athena(n) is a Snit type whose instances represent entire Athena
scenarios.  To create a new scenario, possibly loading an <tt .adb> file,
create an instance of athena(n).  In addition, athena(n) provides 
a number of capabilities that involve analyzing and comparing scenarios.<p>

<section "Relationship with athenadb(n)">

Instances of athena(n) are thin wrappers around <xref athenadb(n)>, which 
is the true main object in the package.  <xref athenadb(n)> also provides
services to internal modules that aren't appropriate for use by clients.<p>

<subsection "Scenario States">

athena(n) defines a state machine to determine what can be done at 
different times, and more specifically which <xref order(n)> orders are
available at any given time.  The state machine is illustrated in the
following diagram (athena(n) subcommands are shown in blue):<p>

<img src="athenadb_state.png"><p>

First, the scenario may be <iref locked> or <iref unlocked>.  While
<iref unlocked>, the scenario may be edited freely.  When the scenario
is <iref locked>, the models are initialized and many inputs become
frozen until the scenario is <iref unlocked> again.<p>

Second, the scenario may be <iref idle> or <iref busy>.  While it is
<iref idle> it is waiting in the event loop for user input.  While it
<iref isbusy>, it is performing some long-running task; the user interface
might be responsive, but input (i.e., orders) cannot be accepted.<p>

Third, any such task can be <iref interruptible> or 
non-<iref interruptible>.  Interruptible tasks can be terminated in the 
middle; other tasks must run to completion.<p>

This leads to the following four states:<p>

<topiclist>
<topic {<b PREP>}>
Scenario preparation.  The scenario is <iref idle> and <iref unlocked>,
and most orders can be used to edit the scenario.
</topic>

<topic {<b PAUSED>}>
The scenario is <iref idle> and <iref locked>; simulation time can be
advanced.
</topic>

<topic {<b BUSY>}>
The scenario <iref isbusy> with a non-<iref interruptible> task.
</topic>

<topic {<b RUNNING>}>
The scenario <iref isbusy> with an <iref interruptible> task.
</topic>
</topiclist><p>

The lock state is set using <iref lock> and <iref unlock>.<p>

The busy state is set using <iref busy>, which also indicates whether 
the task is <iref interruptible> or not.  At present, 
<iref interruptible> tasks are terminated by <iref interrupt>.  Progress
in a busy task is indicated to the user via the <iref progress> 
subcommand.<p>

The <iref busy> controls are primarily for use internally, but may also
be used by the client.<p>


<section "COMMANDS">

This module defines the following commands:<p>

<deflist commands>

<defitem "athena create" {athena create <i name> ?<i options...>?}>

Creates a new instance of athena(n) called <i name>, which becomes a 
Tcl command defined in the current scope; <iref athena create> returns
the fully-qualified form of the name.<p>

The following options may be used:<p>

<deflist options>

<defopt {-adbfile <i filename>}>

If the <i filename> isn't the empty string, it specifies the name of 
an <tt .adb> scenario file to load.  If the named file cannot be loaded, 
athena(n) will throw "<tt ATHENA LOAD>".<p>

Note that this option is read-only after the object is created.<p>

<defopt {-executivecmd <i cmd>}>

A callback command to be used to define application-specific executive
commands.  It is called with on additional argument, the scenario's
<xref executive(n)> component.  This option is read-only after creation.<p>

<defopt {-logdir <i dirname>}>

Specifies the name of log directory; athenadb(n) should create a 
logger(n) object with this <tt -logdir>.<p>

If the object uses background processing, the background thread 
should use the log directory name created by appending ".bg" to this 
directory name.<p>

<defopt {-scratch <i dirname>}>

Names a scratch directory where athenadb(n) can write debugging files.
Defaults to the current working directory.<p>

<defopt {-subject <i name>}>

Specifies the subject <i name> used for any <xref mars:notifier(n)>
events sent by the object.  By default, the <i name> defaults to the
object's fully-qualified command name.<p>

For example, 
athena(n) wraps an <xref mars:sqldocument(n)> object used to contain
the scenario's run-time database (RDB).  When monitoring is enabled, the
RDB can generate <xref mars:notifier(n)> events as tables are updated.<p>

See <xref "NOTIFIER EVENTS"> for more details.<p>

</deflist options>

<defitem "athena diff" {athena diff <i s1> ?<i s2>? ?<i options...>?}>

Compares two scenarios (or one scenario with itself at different 
simulation times) for significant differences, and returns a
<xref comparison(n)> object containing them.<p>  

<i s1> (and <i s2> if given) must be an <xref athena(n)> scenario object.
By default, the command compares <i s1> at time 0 with itself at its latest
simulation time.  If both scenarios are given, it compares <i s1> with
<i s2> at the latest simulation time they have in common.<p>

Throws <b ATHENA INCOMPARABLE> if the two scenarios cannot reasonably be 
compared.<p>

The options are as follows:<p>

<deflist options>

<defopt {-t1 <i week>}>

Specifies the simulation time for the first scenario, overriding the
logic given above.<p>

<defopt {-t2 <i week>}>

Specifies the simulation time for the second scenario (or the second
simulation time for the first scenario if only one is given), 
overriding the logic given above.<p>

</deflist options>

<defitem "athena new" {athena new ?<i options...>?}>

Creates a new instance of athena(n), and returns its name.  The
options are as for <iref athena create>.<p>

</deflist commands>

<section "INSTANCE COMMAND">

Each athena(n) instance has the following subcommands:<p>

<deflist instance>

<defitem absit {<i adb> absit <i subcommand> ?<i args...>?}>

This command gives access to the abstract situations in the scenario.
See <xref athena_absit(n)>.<p>

<defitem actor {<i adb> actor <i subcommand> ?<i args...>?}>

This command gives access to the actors in the scenario.  See
<xref athena_actor(n)>.<p>

<defitem adbfile {<i adb> adbfile}>

Returns the name of the <tt .adb> file loaded on creation, if any, or
the <tt .adb> file name last used for saving, or "" if no <tt .adb> file
has ever been loaded or saved.<p>

<defitem advance {<i obj> advance ?<i options...>?}>

Advances simulation time, provided that the scenario is <iref locked> and
<iref idle>.  With no options, advances time by one tick.<p>

Throws <b ATHENA BUSY> if the scenario <iref isbusy> and 
<b ATHENA UNLOCKED> if the scenario is not <iref locked>.<p>

The options are as follows:<p>

<deflist options>
<defopt {-mode <i mode>}>

The execution mode: <b blocking> (the default), <b foreground>, or 
<b background>.<p>

When <b blocking>, the command returns after it has advanced 
time the specified number of ticks.  The time advance is not 
<iref interruptible>.<p>

When running in the <b foreground>, the command returns after executing
one tick.  The scenario <iref isbusy>, and successive ticks are executed 
in the context of the Tcl event loop.  The process is 
<iref interruptible>, but if the UI will block during each tick.<p>

When running in the <b background>, the scenario <iref isbusy> and the 
entire process is handed over to a background thread.  Running in the
background has a higher start-up and completion cost, but leaves the
foreground thread responsive as the process runs.  At present, 
background runs are not <iref interruptible>, though this may change.<p>

<defopt {-ticks <i ticks>}>
Specifies the number of ticks to advance time.<p>

<defopt {-until <i time>}>
Specifies that time should advance until the specified <i time> in ticks. 
It's an error if <i time> is less than the current sim time.<p>

<defopt {-tickcmd <i cmd>}>
Calls a <i cmd> to be called at the end of each simulation time tick.
It is called with three arguments: a tag, a tick counter, and the total 
number of ticks to run.  The tick counter runs from 0 to the total number
of ticks as time progresses.  While time advances, the tag will be 
<b RUNNING> if the process can be interrupted and <b BUSY> otherwise; and
at the end, the <i cmd> will be called once with a tag of <b COMPLETE>.<p>

By <iref advance> automatically updates the <iref progress> as 
time advances.  If the caller wishes to manage the <iref progress>
itself, the <tt -tickcmd> can return "NO_PROGRESS".<p>

</deflist options>

<defitem agent {<i adb> agent <i subcommand> ?<i args...>?}>

This command gives access to the agents in the scenario.  Agents
are entities that have strategies, and include all actors plus the 
"SYSTEM" agent, which is used to control actions not dependent on
particular actors.  See <xref athena_agent(n)> for the subcommands.<p>


<defitem autogen {<i adb> autogen <i subcommand> ?<i args...>?}>

This command is used to automatically generate entire scenarios 
or parts of scenarios, if desired. See <xref athena_autogen(n)>.<p>

<defitem bean {<i adb> bean <i subcommand> ?<i args...>?}>

Some of the objects in athena(n) are stored as <xref bean(n)> objects,
notably strategies, blocks, conditions, and tactics. This command 
allows the application to query and manipulate beans.  See
<xref athena_bean(n)> for the subcommands.<p>


<defitem bsys {<i adb> bsys <i subcommand> ?<i args...>?}>

This command gives access to the belief systems in the scenario.
See <xref athena_bsys(n)> for the subcommands.<p>

<defitem busy {<i obj> busy <i subcommand> ?<i args...>?}>

This command manages the scenario's "busy" state.  When the scenario is
undertaking some long-running task in the context of the event loop, 
it will mark itself <iref isbusy>; this prevents orders from being accepted 
and the scenario from being changed until the task is complete.
It has the following subcommands:<p>

<deflist busy>
<defitem "busy clear" {<i obj> busy clear}>
Clears the busy state; the scenario will be <iref idle>.<p>

<defitem "busy set" {<i obj> busy set <i busytext> ?<i pausecmd>?}>
Sets the busy state.  The <i busytext> is a brief statement of the
task, e.g., "Running until 2014W01" or "Wizard".  If the <i pausecmd>
is given, it is a command to call to pause or interrupt the task; the
task is then <iref interruptible> by the <iref interrupt> order.  Otherwise,
the task is not interruptible and must run to completion.<p>

While the scenario <iref isbusy>, the task will often use <iref progress>
to keep the user informed as to its progress.<p>
</deflist busy>

<defitem canlock {<i obj> canlock}>

Returns 1 if the scenario passess the on-lock sanity check, and hence
can in theory be locked, and 0 otherwise.<p>


<defitem civgroup {<i adb> civgroup <i subcommand> ?<i args...>?}>

This command gives access to the civilian groups in the scenario.<p>

<deflist civgroup>

<defitem "civgroup exists" {<i adb> civgroup exists TBD}>
<defitem "civgroup get" {<i adb> civgroup get TBD}>
<defitem "civgroup local" {<i adb> civgroup local TBD}>
<defitem "civgroup namedict" {<i adb> civgroup namedict TBD}>
<defitem "civgroup names" {<i adb> civgroup names TBD}>
<defitem "civgroup validate" {<i adb> civgroup validate TBD}>
<defitem "civgroup view" {<i adb> civgroup view TBD}>

</deflist civgroup>


<defitem clock {<i adb> clock <i subcommand> ?<i args...>?}>

TBD: Fill this in.  Refer to <xref weekclock(n)>.  
Consider exposing only certain subcommands.<p>

<defitem contribs {<i adb> contribs <i subcommand> ?<i args...>?}>

TBD: Access to URAM contribs ensemble.  Fill this in.

<defitem curse {<i adb> curse <i subcommand> ?<i args...>?}>

This command gives access to the CURSEs in the scenario.  A
CURSE is a scenario-specific rule set triggered by the CURSE
tactic.s<p>

<deflist curse>

<defitem "curse checker" {<i adb> curse checker TBD}>
<defitem "curse exists" {<i adb> curse exists TBD}>
<defitem "curse get" {<i adb> curse get TBD}>
<defitem "curse namedict" {<i adb> curse namedict TBD}>
<defitem "curse names" {<i adb> curse names TBD}>
<defitem "curse normal" {<i adb> curse normal TBD}>
<defitem "curse validate" {<i adb> curse validate TBD}>

</deflist curse>

<defitem dbsync {<i adb> dbsync}>

Sends out a sequence of notifier events to the client, to be used to
refresh the client when the scenario changes, i.e., after a <iref load>
or <iref reset>.<p>

The sequence is <tt><tag PreSync></tt>, <tt><tag Sync></tt>, 
<tt><tag Time></tt>, and <tt><tag State></tt>.  
See <xref "NOTIFIER EVENTS"> for
more about the notifier events sent by the library.<p>

<defitem econ {<i adb> econ <i subcommand> ?<i args...>?}>

This command gives access to the economic model in the scenario.<p>

<deflist econ>

<defitem "econ state" {<i adb> econ state TBD}>
<defitem "econ report" {<i adb> econ report TBD}>
<defitem "econ hist" {<i adb> econ hist TBD}>
<defitem "econ getcge" {<i adb> econ getcge TBD}>
<defitem "econ getsam" {<i adb> econ getsam TBD}>
<defitem "econ enable" {<i adb> econ enable TBD}>
<defitem "econ disable" {<i adb> econ disable TBD}>

</deflist econ>


<defitem enter {<i obj> enter <i options...>}>

If Tk is loaded, then this command is used to pop up Tk order dialogs.  If
Tk is not loaded, it throws an error. The options are as follows:<p>

<deflist enter>

<defopt {-order <i name>}>

Specifies the order name, e.g., <tt ACTOR:CREATE>.<p>

<defopt {-parmdict <i dict>}>

Specifies a dictionary of order parameter names and values, to be used to
initialize the dialog.<p>

<defopt {-master <i window>}>

Specifies the Tk window over which the dialog should appear.<p>

<defopt {-appname <i name>}>

Specifies the application name for the dialog title.<p>

<defopt {-helpcmd <i cmd>}>

Specifies a command to call if the dialog's help button is pushed.<p>

</deflist enter>

<defitem eval {<i adb> eval <i query> ?<i args...>?}>

Evaluates an SQL <i query> with respect to the scenario's run-time 
database.  The arguments are as for the standard SQLite3 <tt eval>
subcommand.  Queries that attempt to write to the RDB will be
rejected.<p>


<defitem executive {<i adb> executive <i subcommand> ?<i args...>?}>

This ensemble gives access to the scenario's executive interpreter, which 
executes commands and scripts in the context of the scenario.  See the
<xref executive(n)> man page for details about the executive.<p>

Further, the application can add its own commands to the executive by defining
an <tt -executivecmd>.<p>

<defitem exists {<i adb> exists <i query>}>

Evaluates an SQL <i query> with respect to the scenario's run-time 
database, returning 1 if the <i query> would return one or more
rows, and 0 otherwise.  Queries that attempt to write to the RDB will be
rejected.<p>

<defitem export {<i adb> export TBD}>

Exports a scenario as an order script.  TBD: fill in details.<p>

<defitem frcgroup {<i adb> frcgroup <i subcommand> ?<i args...>?}>

This command gives access to the force groups in the scenario.<p>

<deflist frcgroup>

<defitem "frcgroup exists" {<i adb> frcgroup exists TBD}>
<defitem "frcgroup get" {<i adb> frcgroup get TBD}>
<defitem "frcgroup namedict" {<i adb> frcgroup namedict TBD}>
<defitem "frcgroup names" {<i adb> frcgroup names TBD}>
<defitem "frcgroup validate" {<i adb> frcgroup validate TBD}>
<defitem "frcgroup view" {<i adb> frcgroup view TBD}>

</deflist frcgroup>


<defitem getclock {<i adb> getclock}>

Returns the scenario's <xref weekclock(n)> object, so that it can be 
passed to other library modules (e.g., <xref logger(n)>).<p>

<defitem gofer {<i adb> gofer TBD}>

TBD: Interface to gofers; write a separate man page.<p>

<defitem group {<i adb> group <i subcommand> ?<i args...>?}>

This command gives access to the groups (of all three kinds) in the 
scenario.<p>

<deflist group>

<defitem "group exists" {<i adb> group exists TBD}>
<defitem "group get" {<i adb> group get TBD}>
<defitem "group namedict" {<i adb> group namedict TBD}>
<defitem "group names" {<i adb> group names TBD}>
<defitem "group validate" {<i adb> group validate TBD}>
<defitem "group view" {<i adb> group view TBD}>

</deflist group>


<defitem halt {<i adb> halt}>

Returns athena(n) to the <b PAUSED> state if it is in the 
<b RUNNING> state.  The application can use this if 
athena(n) throws an unexpected error while advancing time.<p>

<defitem hook {<i adb> hook <i subcommand> ?<i args...>?}>

This command gives access to the semantic hooks in the scenario.<p>

<deflist hook>

<defitem "hook exists" {<i adb> hook exists TBD}>
<defitem "hook namedict" {<i adb> hook namedict TBD}>
<defitem "hook names" {<i adb> hook names TBD}>
<defitem "hook topic" {<i adb> hook topic TBD}>
<defitem "hook validate" {<i adb> hook validate TBD}>

</deflist hook>

<defitem idle {<i obj> idle}>

Returns 1 if the scenario is idle, i.e., is ready to accept user input,
and 0 otherwise; see <xref "Scenario States">.<p>

<defitem inject {<i adb> inject <i subcommand> ?<i args...>?}>

This command gives access to the Information Ops Message (IOM) injects
in the scenario.<p>

<deflist inject>

<defitem "inject checker" {<i adb> inject checker TBD}>
<defitem "inject exists" {<i adb> inject exists TBD}>
<defitem "inject get" {<i adb> inject get TBD}>
<defitem "inject typenames" {<i adb> inject typenames TBD}>
<defitem "inject validate" {<i adb> inject validate TBD}>

</deflist inject>

<defitem interrupt {<i obj> interrupt}>

If the scenario <iref isbusy> with a task that is <iref interruptible>,
this command will attempt to interrupt it, causing it to terminate 
prematurely; see <iref busy set> for how to specify that the scenario
is doing an interruptible task.<p>

<defitem interruptible {<i obj> interruptible}>

Returns 1 if the scenario <iref isbusy> with an interruptible task,
and 0 otherwise.<p>

<defitem iom {<i adb> iom <i subcommand> ?<i args...>?}>

This command gives access to the Information Ops Message (IOM) objects
in the scenario.<p>

<deflist iom>

<defitem "iom checker" {<i adb> iom checker TBD}>
<defitem "iom exists" {<i adb> iom exists TBD}>
<defitem "iom get" {<i adb> iom get TBD}>
<defitem "iom namedict" {<i adb> iom namedict TBD}>
<defitem "iom names" {<i adb> iom names TBD}>
<defitem "iom normal" {<i adb> iom normal TBD}>
<defitem "iom validate" {<i adb> iom validate TBD}>

</deflist iom>

<defitem is {<i obj> is <i predicate>}>

Returns 1 if the <i predicate> is true and 0 otherwise.  The valid
predicates are as follows:<p>

<deflist is>
<defitem "is advanced" {<i obj> is advanced}>
Returns 1 if the scenario is <iref locked> and its simulation time has
been advanced.<p>

</deflist>

<defitem isbusy {<i obj> isbusy}>

Returns 1 if the scenario is busy, i.e., is performing a task and 
cannot accept user orders, and 0 otherwise; see <xref "Scenario States">.<p>

<defitem load {<i obj> load <i filename>}>

Loads the scenario from the named <tt *.adb> file into this scenario
object, throwing away any previous data.  The scenario must be
<iref idle>.  Afterwards, the scenario will be <i locked> or 
<i unlocked> depending on the loaded data.<p>

If the client depends on <xref "NOTIFIER EVENTS"> to keep its user interface
in sync with the scenario, it should call <iref dbsync> after calling 
<iref load>.<p>

Throws <b ATHENA BUSY> if the scenario <iref isbusy>, and <b ATHENA LOAD>
if the scenario file could not be loaded.<p>

<defitem lock {<i obj> lock}>

Locks the scenario, if the scenario is <iref idle> and <iref unlocked>
and <iref canlock>.  The simulation time can only be advanced while the
scenario is locked.<p>

Throws <b ATHENA BUSY> if the scenario is busy, and <b ATHENA NOTSANE>
if the scenario fails its on-lock sanity check.<p>

<defitem locked {<i obj> locked}>

Returns 1 if the scenario is "locked", initialized and ready for a time
advance, and 0 otherwise; see <xref "Scenario States">.<p>

<defitem onecolumn {<i adb> onecolumn <i query>}>

Evaluates an SQL <i query> with respect to the scenario's run-time 
database, returning only the first column of the first row.
Queries that attempt to modify the RDB will be rejected.<p>

<defitem order {<i adb> order <i subcommand> ?<i args...>?}>

This command gives access to the scenario's <xref mars:order_flunky(n)>
object.<p>

The subcommands are TBD.<p>


<defitem paste {<i obj> paste <i subcommand> ?<i args...>?}>

Pastes copied items into scenario, where the subcommand determines the 
kind of item to paste.  In each case, the paste is done as a sequence of 
grouped orders, and will be undone and redone as a group.<p>

TBD: specify how you get copysets.<p>

The available subcommands are as follows:<p>

<deflist paste>

<defitem "paste block" {<i obj> paste block <i agent copysets>}>

Pastes <i copysets>, a list of copied strategy blocks, into the strategy
owned by the named <i agent>.<p>

<defitem "paste condition" {<i obj> paste condition <i block_id copysets>}>

Pastes <i copysets>, a list of copied conditions, into the strategy block
with the given <i block_id>.<p>

<defitem "paste tactic" {<i obj> paste tactic <i block_id copysets>}>

Pastes <i copysets>, a list of copied tactics, into the strategy block
with the given <i block_id>.<p>

</deflist paste>

<defitem progress {<i obj> progress ?<i value>?}>

Sets and queries the current progress value.  Progress is set while the
scenario <iref isbusy>; see <iref busy set>.  The <i value> may take three
forms:<p>

<topiclist>
<topic {<b user>}>
The user is in control of the scenario.  This would be the case when the
scenario is <i idle> and it <iref isbusy> with something like a wizard GUI,
where normal order entry is suspended until the wizard is closed.
</topic>

<topic {<b wait>}>
The scenario is performing a task of indefinite length, and no actual
progress can be reported until it is done.
</topic>

<topic {<b><i fraction></b>}>
A completion <i fraction> from 0.0 to 1.0.
</topic>
</topiclist><p>

<b TBD>: It might also be good to have a mode for tasks where the duration
cannot be estimated, but many messages are received from the task code.
This would allow a <tt ttk::progressbar> to be animated by the receipt
of these messages instead of automatically, which would give the user
more feedback.<p>


<defitem ptype {<i obj> ptype <i subcommand> ?<i args...>?}>

Parameter type validation subcommands.  This is exposed because it is used by
the Athena Workbench's "view" mechanism.  Ultimately, that should be replaced 
by a gofer-based solution; when that happens, this module can become private.<p>

<defitem query {<i adb> query <i query> ?<i options...>?}>

Evaluates an SQL <i query> with respect to the scenario's run-time 
database, and returns the result set as a formatted string.  The 
<i query> can contain any valid SQL statements understood by SQLite3,
but in practice it will be a single statement that returns a result 
set (i.e., <tt SELECT> or certain <tt PRAGMA> statements).  Queries
that attempt to write to the RDB will be rejected.<p>

The following options may be used:<p>

<deflist query>

<defopt {-mode mc|list|csv}>

Specifies the output mode; the default is <b>mc</b>, multicolumn.<p>

When <tt -mode> is <b>mc</b>, each record is output on a single
line.  Fields are formatted in columns, with the field name as the
column header.<p>

When <tt -mode> is <b>list</b>, the output is a list of records.
Each record is output on multiple lines, with (nominally) one line
per field.  Each line consists of the field name and value; the
record's field names are values are formatted neatly in parallel columns.<p>

When <tt -mode> is <b>csv</b>, the output is in CSV (comma-separated value)
format, one record per line, beginning with a header record of column labels.
Non-numeric values are enclosed in double-quotes.<p>

<defopt {-labels <i>list</i>}>

Normally <iref query> uses the column names found in the query to
label the fields in the output.  If specified, the value of
<b>-labels</b> is a list of labels to be used instead.<p>

<defopt {-maxcolwidth <i>chars</i>}>

Sets the maximum column width, in characters, when <tt -mode> is
<b>mc</b>; the default is 30.  All
data values longer than this will be truncated with "...".<p>

If <b>-maxcolwidth</b> is set to 0 then values will not be
truncated.<p>

<defopt {-headercols <i>num</i>}>

Sets the number of header columns.  When <tt -mode> is <b>mc</b>,
repeated values in a column are skipped.  That is, if a column
contains identical values in consecutive rows, the column will be
blank in all but the first of the rows.  Defaults to "0".<p>

</deflist query>

<defitem rdb {<i adb> rdb <i subcommand> ?<i args...>?}>

This command gives full read/write access to the Run-Time Database (RDB),
a <xref scenariodb(n)> object.  Its write capability is intended for use
in debugging and test; use it with care.<p>

<defitem reset {<i obj> reset}>

Resets the scenario back to its initial empty state.  It will be 
<iref idle> and <i unlocked>.<p>

If the client depends on <xref "NOTIFIER EVENTS"> to keep its user interface
in sync with the scenario, it should call <iref dbsync> after calling 
<iref load>.<p>

Throws <b ATHENA BUSY> if the scenario <iref isbusy>.<p>

<defitem sanity {<i obj> sanity <i subcommand> ?<i args...>?}>

TBD: Sanity-checking module; fill this in.<p>

<defitem save {<i obj> save ?<i filename>?}>

Saves the scenario to disk as an <tt .adb> file called <i filename>,
adding the "<tt .adb>" extension if necessary.  If no <i filename> is
given but the <iref adbfile> name is known, the <iref adbfile> name is
used.  The scenario is marked saved.<p>

On failure, throws "<tt ATHENA SAVE>".<p>

<defitem state {<i obj> state}>

Returns the scenario's state, which depends on whether or not it is
<iref idle> and whether or not it is <iref locked>.  The states are
<b PREP>, <b PAUSED>, <b BUSY>, and <b RUNNING>; see 
<xref "Scenario States"> for more details.<p>

<defitem statetext {<i obj> statetext}>

Returns a human-readable string that derives from the current 
<iref state>.  If the scenario <iref isbusy>, the string is simply
the <i busytext> passes to <iref busy set>.<p>

<defitem stoptime {<i obj> stoptime}>

While the <i state> is <b RUNNING>, this method returns the simulation
time in weeks at which the simulation will stop and return to the 
<b PAUSED> state.<p>

<defitem unlock {<i obj> unlock}>

Unlocks the scenario, if the scenario is <iref idle> and <iref locked>.
The scenario can only be edited while it is unlocked.<p>

Throws <b ATHENA BUSY> if the scenario <iref isbusy>.<p>

<defitem unlocked {<i obj> unlocked}>

Returns 1 if the scenario is "unlocked", ready for editing, and 0
otherwise; see <xref "Scenario States">.<p>

<defitem unsaved {<i obj> unsaved}>

Returns 1 if there is unsaved scenario data, and 0 otherwise.<p>

<defitem version {<i obj> version}>

Returns the version number of the <xref athena(n)> library.<p>

</deflist instance>

<section FUNCTIONS>

athena(n) defines many SQL functions for use in database queries.  The
functions are TBD.<p>

<section "NOTIFIER EVENTS">

athena(n) and its subcomponents send <xref notifier(n)> events.  Top-level
events are sent by the <tt -subject> indicated when the instance is created.
Individual subcomponents can also send events; in this case, the 
<xref notifier(n)> subject is "<i subject>.<i component>".  If the 
<tt -subject> is "<tt ::adb>", for example, the order flunky component
sends events as "<tt ::adb.flunky>".<p>

<b TBD>: This section should document all notifier events sent by
athena(n), including those by subcomponents.<p>

<deflist events>

<defitem Create {<i subject> <tag Create>}>

The athena(n) instance sends this event on creation, after it is fully
initialized.  This is useful when an application reuses the same 
<tt -subject> for successive scenarios, as it allows GUI modules to 
initialize themselves.<p>

<defitem Destroy {<i subject> <tag Destroy>}>

The athena(n) instance sends this event when it is destroyed.  This allows
client modules to clean up references to the object and its subcomponents.
<p>

</deflist>

<section AUTHOR>

Will Duquette<p>

<section HISTORY>

New package derived from Athena internals.<p>

</manpage>




