<manpage {athena(n)} "Athena Scenario Type">

<section SYNOPSIS>

<pre>
package require athena <version>
namespace import ::athena::*
</pre>

<itemlist>

<section DESCRIPTION>

athena(n) is the primary public interface for the athena(n) package.
athena(n) is a Snit type whose instances represent entire Athena
scenarios.  To create a new scenario, possibly loading an <tt .adb> file,
create an instance of athena(n).  In addition, athena(n) provides 
a number of capabilities that involve analyzing and comparing scenarios.<p>

<section "Relationship with athenadb(n)">

Instances of athena(n) are thin wrappers around <xref athenadb(n)>, which 
is the true main object in the package.  <xref athenadb(n)> also provides
services to internal modules that aren't appropriate for use by clients.<p>

<subsection "Scenario States">

athena(n) defines a state machine to determine what can be done at 
different times, and more specifically which <xref order(n)> orders are
available at any given time.  The state machine is illustrated in the
following diagram (athena(n) subcommands are shown in blue):<p>

<img src="athenadb_state.png"><p>

First, the scenario may be <iref locked> or <iref unlocked>.  While
<iref unlocked>, the scenario may be edited freely.  When the scenario
is <iref locked>, the models are initialized and many inputs become
frozen until the scenario is <iref unlocked> again.<p>

Second, the scenario may be <iref idle> or <iref busy>.  While it is
<iref idle> it is waiting in the event loop for user input.  While it
<iref isbusy>, it is performing some long-running task; the user interface
might be responsive, but input (i.e., orders) cannot be accepted.<p>

Third, any such task can be <iref interruptible> or 
non-<iref interruptible>.  Interruptible tasks can be terminated in the 
middle; other tasks must run to completion.<p>

This leads to the following four states:<p>

<topiclist>
<topic {<b PREP>}>
Scenario preparation.  The scenario is <iref idle> and <iref unlocked>,
and most orders can be used to edit the scenario.
</topic>

<topic {<b PAUSED>}>
The scenario is <iref idle> and <iref locked>; simulation time can be
advanced.
</topic>

<topic {<b BUSY>}>
The scenario <iref isbusy> with a non-<iref interruptible> task.
</topic>

<topic {<b RUNNING>}>
The scenario <iref isbusy> with an <iref interruptible> task.
</topic>
</topiclist><p>

The lock state is set using <iref lock> and <iref unlock>.<p>

The busy state is set using <iref busy>, which also indicates whether 
the task is <iref interruptible> or not.  At present, 
<iref interruptible> tasks are terminated by <iref interrupt>.  Progress
in a busy task is indicated to the user via the <iref progress> 
subcommand.<p>

The <iref busy> controls are primarily for use internally, but may also
be used by the client.<p>


<section "COMMANDS">

This module defines the following commands:<p>

<deflist commands>

<defitem "athena create" {athena create <i name> ?<i options...>?}>

Creates a new instance of athena(n) called <i name>, which becomes a 
Tcl command defined in the current scope; <iref athena create> returns
the fully-qualified form of the name.<p>

The following options may be used:<p>

<deflist options>

<defopt {-adbfile <i filename>}>

If the <i filename> isn't the empty string, it specifies the name of 
an <tt .adb> scenario file to load.  If the named file cannot be loaded, 
athena(n) will throw "<tt SCENARIO OPEN>".<p>

Note that this option is read-only after the object is created.<p>

<defopt {-executivecmd <i cmd>}>

A callback command to be used to define application-specific executive
commands.  It is called with on additional argument, the scenario's
<xref executive(n)> component.  This option is read-only after creation.<p>

<defopt {-logdir <i dirname>}>

Specifies the name of log directory; athenadb(n) should create a 
logger(n) object with this <tt -logdir>.<p>

If the object uses background processing, the background thread 
should use the log directory name created by appending ".bg" to this 
directory name.<p>

<defopt {-scratch <i dirname>}>

Names a scratch directory where athenadb(n) can write debugging files.
Defaults to the current working directory.<p>

<defopt {-subject <i name>}>

Specifies the subject <i name> used for any <xref mars:notifier(n)>
events sent by the object.  By default, the <i name> defaults to the
object's fully-qualified command name.<p>

For example, 
athena(n) wraps an <xref mars:sqldocument(n)> object used to contain
the scenario's run-time database (RDB).  When monitoring is enabled, the
RDB can generate <xref mars:notifier(n)> events as tables are updated.<p>

See <xref "NOTIFIER EVENTS"> for more details.<p>

</deflist options>

<defitem "athena diff" {athena diff <i s1> ?<i s2>? ?<i options...>?}>

Compares two scenarios (or one scenario with itself at different 
simulation times) for significant differences, and returns a
<xref comparison(n)> object containing them.<p>  

<i s1> (and <i s2> if given) must be an <xref athena(n)> scenario object.
By default, the command compares <i s1> at time 0 with itself at its latest
simulation time.  If both scenarios are given, it compares <i s1> with
<i s2> at the latest simulation time they have in common.<p>

The options are as follows:<p>

<deflist options>

<defopt {-t1 <i week>}>

Specifies the simulation time for the first scenario, overriding the
logic given above.<p>

<defopt {-t2 <i week>}>

Specifies the simulation time for the second scenario (or the second
simulation time for the first scenario if only one is given), 
overriding the logic given above.<p>

</deflist options>

<defitem "athena new" {athena new ?<i options...>?}>

Creates a new instance of athena(n), and returns its name.  The
options are as for <iref athena create>.<p>

</deflist commands>

<section "INSTANCE COMMAND">

Each athena(n) instance has the following subcommands:<p>

<deflist instance>

<defitem absit {<i adb> absit <i subcommand> ?<i args...>?}>

This command gives access to the abstract situations in the scenario.<p>

<deflist absit>

<defitem "absit exists" {<i adb> absit exists <i s>}>

Returns 1 if there is an absit with ID <i s>, and 0 otherwise.<p>

<defitem "absit get" {<i adb> absit get <i s> ?<i parm>?}>

By default, returns a dictionary of information about the absit with
ID <i s> (the dictionary is consistent with the <tt absits> SQL table).
If <i parm> is given, it returns the value of that entry in the dict.<p>

<defitem "absit isinitial" {<i adb> absit isinitial <i s>}>

Returns 1 if absit <i s> is in the initial state, and 0 otherwise.<p>

<defitem "absit islive" {<i adb> absit islive <i s>}>

Returns 1 if absit <i s> is "live", i.e., it has not been resolved,
and 0 otherwise.<p>

<defitem "absit names" {<i adb> absit names}>
Returns a list of the IDs of the existing absits.<p>

<defitem "absit validate" {<i adb> absit validate <i s>}>
Validates <i s> as an absit ID, returning it if it is valid and
throwing <b INVALID> otherwise.<p>

<defitem "absit view" {<i adb> absit view <i s> ?<i tag>?}>

By default, returns a dictionary of information about the absit with
ID <i s>, consistent with the <tt gui_absits> SQL view.  The <i tag>
allows the command to tailor its output for different output formats
(e.g., html); at present it is ignored.<p>

</deflist absit>

<defitem actor {<i adb> actor <i subcommand> ?<i args...>?}>

This command gives access to the actors in the scenario.<p>

<deflist actor>

<defitem "actor exists" {<i adb> actor exists <i a>}>
Returns 1 if there is an actor with ID <i a>, and 0 otherwise.<p>

<defitem "actor get" {<i adb> actor get <i a> ?<i parms>?}>
By default, returns a dictionary of information about actor <i a>
(the dictionary is consistent with the <tt absits> SQL table).
If <i parm> is given, it returns the value of that entry in the dict.<p>

<defitem "actor namedict" {<i adb> actor namedict}>
Returns a dictionary of actor IDs and long names for all actors in the
scenario.<p>

<defitem "actor names" {<i adb> actor names}>
Returns a list of actor IDs for all actors in the scenario.<p>

<defitem "actor validate" {<i adb> actor validate <i a>}>
Validates <i a> as an actor ID, returning it if it is valid and
throwing <b INVALID> otherwise.<p>

<defitem "actor view" {<i adb> actor view <i a> ?<i tag>?}>

By default, returns a dictionary of information about actor <i a>
consistent with the <tt gui_actors> SQL view.  The <i tag>
allows the command to tailor its output for different output formats
(e.g., html); at present it is ignored.<p>

</deflist actor>

<defitem adbfile {<i adb> adbfile}>

Returns the name of the <tt .adb> file loaded on creation, if any, or
the <tt .adb> file name last used for saving, or "" if no <tt .adb> file
has ever been loaded or saved.<p>

<defitem advance {<i obj> advance ?<i options...>?}>

Advances simulation time, provided that the scenario is <iref locked> and
<iref idle>.  With no options, advances time by one tick.<p>

The options are as follows:<p>

<deflist options>
<defopt {-mode <i mode>}>

The execution mode: <b blocking> (the default), <b foreground>, or 
<b background>.<p>

When <b blocking>, the command returns after it has advanced 
time the specified number of ticks.  The time advance is not 
<iref interruptible>.<p>

When running in the <b foreground>, the command returns after executing
one tick.  The scenario <iref isbusy>, and successive ticks are executed 
in the context of the Tcl event loop.  The process is 
<iref interruptible>, but if the UI will block during each tick.<p>

When running in the <b background>, the scenario <iref isbusy> and the 
entire process is handed over to a background thread.  Running in the
background has a higher start-up and completion cost, but leaves the
foreground thread responsive as the process runs.  At present, 
background runs are not <iref interruptible>, though this may change.<p>

<defopt {-ticks <i ticks>}>
Specifies the number of ticks to advance time.<p>

<defopt {-until <i time>}>
Specifies that time should advance until the specified <i time> in ticks. 
It's an error if <i time> is less than the current sim time.<p>

<defopt {-tickcmd <i cmd>}>
Calls a <i cmd> to be called at the end of each simulation time tick.
It is called with three arguments: a tag, a tick counter, and the total 
number of ticks to run.  The tick counter runs from 0 to the total number
of ticks as time progresses.  While time advances, the tag will be 
<b RUNNING> if the process can be interrupted and <b BUSY> otherwise; and
at the end, the <i cmd> will be called once with a tag of <b COMPLETE>.<p>

By <iref advance> automatically updates the <iref progress> as 
time advances.  If the caller wishes to manage the <iref progress>
itself, the <tt -tickcmd> can return "NO_PROGRESS".<p>

</deflist options>

<defitem agent {<i adb> agent <i subcommand> ?<i args...>?}>

This command gives access to the agents in the scenario.  Agents
are entities that have strategies, and include all actors plus the 
"SYSTEM" agent, which is used to control actions not dependent on
particular actors.<p>

<deflist agent>

<defitem "agent exists" {<i adb> agent <i agent_id>}>
Returns 1 if there is an agent with ID <i agent_id>, and 0 otherwise.<p>

<defitem "agent names" {<i adb> agent names}>
Returns a list of agent IDs for all agents in the scenario.<p>

<defitem "agent stats" {<i adb> agent stats <i agent_id>}>
Returns a dictionary of statistics about the specified agent's strategy:<p>

<ul>
<li> <b blocks>: The total number of blocks
<li> <b conditions>: The total number of conditions
<li> <b tactics>: The total number of tactics
</ul><p>

<defitem "agent tactictypes" {<i adb> agent tactictypes <i agent_id>}>

Returns a list of the names of the tactic types that this agent is
allowed to use.<p>

<defitem "agent type" {<i adb> agent type <i agent_id>}>

Returns the type of this agent, either <b system> or <b actor>.<p>

<defitem "agent validate" {<i adb> agent validate <i agent_id>}>

Validates <i agent_id> as an agent ID, returning it if it is valid and
throwing <b INVALID> otherwise.<p>


</deflist agent>


<defitem autogen {<i adb> autogen <i subcommand> ?<i args...>?}>

This command is used to automatically generate entire scenarios 
or parts of scenarios, if desired. It has the following subcommands:<p>

<deflist autogen>

<defitem "autogen scenario" {<i adb> autogen scenario <i options...>}>

Creates a scenario with a default number of each of Athena's entities
or, if any of the options are supplied, the number of entities 
requested by the user. If the <i>-nostrategy</i> flag is supplied then
no tactics are created, otherwise a default set of tactics are created 
for each actor.<p>

The available options are:<p>

<deflist options>

<defopt {-nb <i>n</i>}>
Specifies the number of neighborhoods to create. Each neighborhood is
a 10x10 pixel square. Neighborhoods are laid out in strips starting at
the top of the map. Defaults to 10.<p>

<defopt {-actors <i>n</i>}>
Specifies the number of actors to create. Defaults to 3.<p>

<defopt {-frcg <i>n</i>}>
Specifies the number of force groups to create. As they are created,
the force group type is cycled through each possible type. Each force 
group is given a base personnel of 100000. Defaults to 3.<p>

<defopt {-civg <i>n</i>}>
Specifies the number of civilian groups to create per neighborhood. The 
last group in each neighborhood is created with the subsistence 
agriculture flag set to true. The different types of housing are 
cycled through as each group is created. The exception to this are 
subsistence agriculture groups, which are always  
<code>AT_HOME</code>.  The population of every group in a neighborhood 
is some non-negative multiple of 10000. Thus, the first group in a 
neighborhood has a base population of zero and each group created 
after has a base population of 10000 more than the previous group.
Defaults to 6.<p>

<defopt {-orgg <i>n</i>}>
Specifies the number of organization groups to create. As groups are
created, the organization type is cycled through. Each group has a 
base personnel of 100000. Defaults to 2.<p>

<defopt {-topics <i>n</i>}>
Specifies the number of belief system topics to create.  Each actor and
civilian group is given its own belief system, and assigned a belief 
for each topic.  The beliefs
assigned are cycled through four possibilities comprised of a position
and emphasis pair. They are:

<ul>
<li><b>Passionately For</b> and <b>Agreement--Strong</b>
<li><b>Passionately For</b> and <b>Disagreement--Extreme</b>
<li><b>Passionately Against</b> and <b>Agreement--Strong</b>
<li><b>Passionately Against</b> and <b>Disagreement--Extreme</b>
</ul>

Note that if 4 topics are requested then all actors and
civilians will have identical belief systems resulting in affinities of
1 between all entity pairs. Defaults to 3.<p>

<defopt {-nostrategy}>
If specified, no tactics are employed by any actor.<p>

</deflist options>

To create a scenario with 8 neighborhoods and the default number of
entities for all others, enter<p>

<pre>
    autogen scenario -nb 8
</pre>

To create a scenario with no tactics for any actor, enter<p>

<pre>
    autogen scenario -nostrategy
</pre>

<defitem "autogen actors" {<i adb> autogen actors ?<i num>?}>

Automatically generates the requested number of actors provided that
no actors already exist.  If no argument is supplied, three actors are
created.<p>

<defitem "autogen nbhoods" {<i adb> autogen nbhoods ?<i num>?}>

Automatically generates the requested number of neighborhoods 
subject to certain constraints. Each neighborhood is
a 10x10 pixel square. Neighborhoods are laid out in strips starting at
the top of the map. If no argument is supplied, 
ten neighborhoods are created. The constraints are as follows:<p> 

<ul>
<li> No neighborhoods exist
<li> At least one actor exists
</ul><p>

<defitem "autogen civgroups" {<i adb> autogen civgroups ?<i num>?}>

Automatically generates the requested number of civilian groups per
neighborhood. The last group in each neighborhood is created with 
the subsistence agriculture flag set to true. The different types 
of housing are cycled through as each group is created. The exception
to this are subsistence agriculture groups, which are
always <code>AT_HOME</code>. The population of every group in a 
neighborhood is some non-negative multiple of 10000. Thus, the first
group in a neighborhood has a base population of zero and each group 
created after has a base population of 10000 more than the previous 
group.  If no argument is supplied, six groups per neighborhood are 
created.<p>

The creation of civilian groups is subject to the following constraints:<p> 

<ul>
<li> Neighborhoods must exist
<li> No civilian groups exist
</ul><p>

<defitem "autogen frcgroups" {<i adb> autogen frcgroups ?<i num>?}>

Specifies the number of force groups to create. As they are created,
force group type is cycled through each possible type. Each force 
group is given a base personnel of 100000.  If no argument is supplied, 
three groups are created. <p>

The creation of force groups is subject to the following constraints:<p> 

<ul>
<li> At least one actor must exist
<li> No force groups exist
</ul><p>

<defitem "autogen orggroups" {<i adb> autogen orggroups ?<i num>?}>

Specifies the number of organization groups to create. As they are created,
organization group type is cycled through each possible type. Each
group is given a base personnel of 100000.  If no argument is supplied, 
three groups are created. <p>

The creation of organization groups is subject to the following 
constraints:<p> 

<ul>
<li> At least one actor must exist
<li> No force groups exist
</ul><p>

<defitem "autogen bsystem" {<i adb> autogen bsystem ?<i num>?}>

Specifies the number of belief system topics to create.  Each actor and
civilian group is given its own belief system, and is assigned a belief 
for each topic.  The beliefs
assigned are cycled through four possibilities comprised of a position
and emphasis pair. They are:

<ul>
<li><b>Passionately For</b> and <b>Agreement--Strong</b>
<li><b>Passionately For</b> and <b>Disagreement--Extreme</b>
<li><b>Passionately Against</b> and <b>Agreement--Strong</b>
<li><b>Passionately Against</b> and <b>Disagreement--Extreme</b>
</ul>

If no argument is supplied, three topics are created.<p>

Creation of a belief system is subject to the following constraints. 
The constraints are as follows:<p> 

<ul>
<li> At least one actor must exist
<li> Civilian groups must exist
<li> No topics exist
</ul><p>


<defitem "autogen assign" {<i adb> autogen assign ?<i options>?}>

This command automatically generates one or more 
ASSIGN tactics for force or organization groups
that belong to the specified owner.  By default all activities are
assigned in turn for each neighborhood.  For each tactic created,
100 personnel are specified to be doing the activity.  The list
of available options are:<p>

<deflist options>

<defopt {-frcg <i>glist</i>}>
List of force groups owned by owner that should be assigned activities.
Defaults to all force groups owned by the owner.<p>

<defopt {-orgg <i>glist</i>}>
List of organization groups owned by owner that should be assigned
activities. Defaults to all organization groups owned by owner.<p>

<defopt {-nbhoods <i>nlist</i>}>
List of neighborhoods that activities should be assigned in.  Defaults
to all neighborhoods.<p>

<defopt {-frcact <i>alist</i>}>
List of force activities that should be assigned, in turn, to each
force group in each neighborhood.  Defaults to all force activities.<p>

<defopt {-orgact <i>alist</i>}>
List of organization activities that should be assigned, in turn, to each
organization group in each neighborhood.  Defaults to all organization
activities.<p>

</deflist options>

</deflist autogen>


<defitem bean {<i adb> bean <i subcommand> ?<i args...>?}>

Some of the objects in athena(n) are stored at <xref bean(n)> objects,
notably strategies, blocks, conditions, and tactics. This command 
allows the application to query and manipulate beans.<p>

<deflist bean>

<defitem "bean get" {<i adb> bean get <i id>}>

Returns the bean object with the given <i id>.  It is an error if no
such bean exists in the scenario.<p>

<defitem "bean has" {<i adb> bean has <i id>}>
Returns 1 if the scenario has a bean object with the given ID, and 0
otherwise.<p>

<defitem "bean ids" {<i adb> bean ids ?<i cls>?}>

By default, returns a list of the IDs of all beans in the scenario.  
If <i cls> is given, returns a list of the IDs of the beans that belong
to that class or its subclasses.  For example, passing 
class <tt ::athena::tactic> will return the IDs of all tactic beans.<p>


<defitem "bean view" {<i adb> bean view <i id> ?<i tag>?}>

Returns a view dictionary for the bean with the given <i id>.  The
<i tag> is used to tailor the information in specific ways; most beans
support the <b text> and <b html> tags.<p>

</deflist bean>

<defitem bsys {<i adb> bsys <i subcommand> ?<i args...>?}>

This command gives access to the belief systems in the scenario.<p>

<deflist bsys>

<defitem "bsys affinity" {<i adb> bsys affinity <i sid1 sid2>}>
Returns the belief system <i sid1>'s affinity for belief system
<i sid2>.  Affinity is a number between -1.0 and 1.0.<p>

<defitem "bsys belief" {<i adb> bsys belief <i subcommand> ?<i args>?}>

This command is used to query the beliefs in a belief system.  The
subcommands are as follows:<p>

<deflist bsys belief>

<defitem "bsys belief view" {<i adb> bsys belief view <i sid tid>}>
Returns a dictionary of information about system <i sid>'s belief about
topic <i tid>.<p>

<defitem "bsys belief validate" {<i adb> bsys belief validate <i bid>}>

Validates <i bid> as an {<i sid tid>} pair for this scenario.  Returns
the <i bid>, or throws <b INVALID> on failure.<p>

<defitem "bsys belief isdefault" {<i adb> bsys belief isdefault <i bid>}>

Returns 1 if belief <i bid> has its default value, and 0 otherwise, where
<i bid> is a valid {<i sid tid>} pair.<p>

</deflist bsys belief>


<defitem "bsys playbox" {<i adb> bsys playbox <i subcommand> ?<i args>?}>

This command is used to query information about the beliefs of the entire
playbox.<p>

<deflist bsys playbox>

<defitem "bsys playbox cget" {<i adb> bsys playbox cget <i option>}>

Returns the value of the named option.  Options include:<p>

<deflist options>

<defopt {-gamma <i value>}> 
This is the playbox "commonality" dial; it
controls the degree of implicit commonality among the entities in the
playbox, that is, the number of implicit topics about which there is
general (and passionate) agreement in the playbox. If <tt -gamma> is 0,
there is no implicit commonality; only explicit topics are considered. If
<tt -gamma> is 1.0 there are as many implicit topics as explicit topics; if
0.5, half as many; if 2.0, twice as many. The value must be no less than
0.0; default is 1.0.     
</deflist options>

</deflist bsys playbox>

<defitem "bsys system" {<i adb> bsys system <i subcommand> ?<i args>?}>

This command is used to query information about entire belief systems.<p>

<deflist bsys system>
<defitem "bsys system cget" {<i adb> bsys system cget <i sid option>}>
Retrieves the value of the given <i option> for belief system <i sid>.
Valid options are as follows:<p>

<deflist options>
<defopt {-name name}>
This is the name of the belief system, for display to the user. 
Names must be unique across belief systems. The default name is 
"System sid".<p>

<defopt {-commonality value}>
This is the belief system "commonality" dial; it specifies the extent of
the system's participation in the dominant culture in the playbox. If 1.0,
the system shares all of the implicit cultural commonality; if 0.0, none of
it. Defaults to 1.0. Note that the effect of this option depends on the
playbox <tt -gamma> value; see <iref bsys playbox cget>.<p>

</deflist options>

<defitem "bsys system exists" {<i adb> bsys system exists <i sid>}>
Returns 1 if the belief system exists, and 0 otherwise.<p>

<defitem "bsys system ids" {<i adb> bsys system ids}>
Returns a list of the IDs of the defined belief systems.<p>

<defitem "bsys system inuse" {<i adb> bsys system inuse <i sid>}>
Returns 1 if the given belief system is assigned to at least one
actor or group, and 0 otherwise.<p>

<defitem "bsys system validate" {<i adb> bsys system validate <i sid>}>

Returns <i sid> if it is a valid belief system ID, and throws 
<b INVALID> otherwise.<p>

</deflist bsys system>

<defitem "bsys topic" {<i adb> bsys topic <i subcommand> ?<i args>?}>

<b TBD:> Continue here!

</deflist bsys>

<defitem busy {<i obj> busy <i subcommand> ?<i args...>?}>

This command manages the scenario's "busy" state.  When the scenario is
undertaking some long-running task in the context of the event loop, 
it will mark itself <iref isbusy>; this prevents orders from being accepted 
and the scenario from being changed until the task is complete.
It has the following subcommands:<p>

<deflist busy>
<defitem "busy clear" {<i obj> busy clear}>
Clears the busy state; the scenario will be <iref idle>.<p>

<defitem "busy set" {<i obj> busy set <i busytext> ?<i pausecmd>?}>
Sets the busy state.  The <i busytext> is a brief statement of the
task, e.g., "Running until 2014W01" or "Wizard".  If the <i pausecmd>
is given, it is a command to call to pause or interrupt the task; the
task is then <iref interruptible> by the <iref interrupt> order.  Otherwise,
the task is not interruptible and must run to completion.<p>

While the scenario <iref isbusy>, the task will often use <iref progress>
to keep the user informed as to its progress.<p>
</deflist busy>

<defitem canlock {<i obj> canlock}>

Returns 1 if the scenario passess the on-lock sanity check, and hence
can in theory be locked, and 0 otherwise.<p>


<defitem civgroup {<i adb> civgroup <i subcommand> ?<i args...>?}>

This command gives access to the civilian groups in the scenario.<p>

<deflist civgroup>

<defitem "civgroup exists" {<i adb> civgroup exists TBD}>
<defitem "civgroup get" {<i adb> civgroup get TBD}>
<defitem "civgroup local" {<i adb> civgroup local TBD}>
<defitem "civgroup namedict" {<i adb> civgroup namedict TBD}>
<defitem "civgroup names" {<i adb> civgroup names TBD}>
<defitem "civgroup validate" {<i adb> civgroup validate TBD}>
<defitem "civgroup view" {<i adb> civgroup view TBD}>

</deflist civgroup>


<defitem clock {<i adb> clock <i subcommand> ?<i args...>?}>

TBD: Fill this in.  Refer to <xref weekclock(n)>.  
Consider exposing only certain subcommands.<p>

<defitem contribs {<i adb> contribs <i subcommand> ?<i args...>?}>

TBD: Access to URAM contribs ensemble.  Fill this in.

<defitem curse {<i adb> curse <i subcommand> ?<i args...>?}>

This command gives access to the CURSEs in the scenario.  A
CURSE is a scenario-specific rule set triggered by the CURSE
tactic.s<p>

<deflist curse>

<defitem "curse checker" {<i adb> curse checker TBD}>
<defitem "curse exists" {<i adb> curse exists TBD}>
<defitem "curse get" {<i adb> curse get TBD}>
<defitem "curse namedict" {<i adb> curse namedict TBD}>
<defitem "curse names" {<i adb> curse names TBD}>
<defitem "curse normal" {<i adb> curse normal TBD}>
<defitem "curse validate" {<i adb> curse validate TBD}>

</deflist curse>

<defitem dbsync {<i adb> dbsync}>

Sends out a sequence of notifier events to the client, to be used to
refresh the client when the scenario changes, i.e., after a <iref load>
or <iref reset>.<p>

The sequence is <tt><tag PreSync></tt>, <tt><tag Sync></tt>, 
<tt><tag Time></tt>, and <tt><tag State></tt>.  
See <xref "NOTIFIER EVENTS"> for
more about the notifier events sent by the library.<p>

<defitem econ {<i adb> econ <i subcommand> ?<i args...>?}>

This command gives access to the economic model in the scenario.<p>

<deflist econ>

<defitem "econ state" {<i adb> econ state TBD}>
<defitem "econ report" {<i adb> econ report TBD}>
<defitem "econ hist" {<i adb> econ hist TBD}>
<defitem "econ getcge" {<i adb> econ getcge TBD}>
<defitem "econ getsam" {<i adb> econ getsam TBD}>
<defitem "econ enable" {<i adb> econ enable TBD}>
<defitem "econ disable" {<i adb> econ disable TBD}>

</deflist econ>


<defitem enter {<i obj> enter <i options...>}>

If Tk is loaded, then this command is used to pop up Tk order dialogs.  If
Tk is not loaded, it throws an error. The options are as follows:<p>

<deflist enter>

<defopt {-order <i name>}>

Specifies the order name, e.g., <tt ACTOR:CREATE>.<p>

<defopt {-parmdict <i dict>}>

Specifies a dictionary of order parameter names and values, to be used to
initialize the dialog.<p>

<defopt {-master <i window>}>

Specifies the Tk window over which the dialog should appear.<p>

<defopt {-appname <i name>}>

Specifies the application name for the dialog title.<p>

<defopt {-helpcmd <i cmd>}>

Specifies a command to call if the dialog's help button is pushed.<p>

</deflist enter>

<defitem eval {<i adb> eval <i query> ?<i args...>?}>

Evaluates an SQL <i query> with respect to the scenario's run-time 
database.  The arguments are as for the standard SQLite3 <tt eval>
subcommand.  Queries that attempt to write to the RDB will be
rejected.<p>


<defitem executive {<i adb> executive <i subcommand> ?<i args...>?}>

This ensemble gives access to the scenario's executive interpreter, which 
executes commands and scripts in the context of the scenario.  See the
<xref executive(n)> man page for details about the executive.<p>

Further, the application can add its own commands to the executive by defining
an <tt -executivecmd>.<p>

<defitem exists {<i adb> exists <i query>}>

Evaluates an SQL <i query> with respect to the scenario's run-time 
database, returning 1 if the <i query> would return one or more
rows, and 0 otherwise.  Queries that attempt to write to the RDB will be
rejected.<p>

<defitem export {<i adb> export TBD}>

Exports a scenario as an order script.  TBD: fill in details.<p>

<defitem frcgroup {<i adb> frcgroup <i subcommand> ?<i args...>?}>

This command gives access to the force groups in the scenario.<p>

<deflist frcgroup>

<defitem "frcgroup exists" {<i adb> frcgroup exists TBD}>
<defitem "frcgroup get" {<i adb> frcgroup get TBD}>
<defitem "frcgroup namedict" {<i adb> frcgroup namedict TBD}>
<defitem "frcgroup names" {<i adb> frcgroup names TBD}>
<defitem "frcgroup validate" {<i adb> frcgroup validate TBD}>
<defitem "frcgroup view" {<i adb> frcgroup view TBD}>

</deflist frcgroup>


<defitem getclock {<i adb> getclock}>

Returns the scenario's <xref weekclock(n)> object, so that it can be 
passed to other library modules (e.g., <xref logger(n)>).<p>

<defitem gofer {<i adb> gofer TBD}>

TBD: Interface to gofers; write a separate man page.<p>

<defitem group {<i adb> group <i subcommand> ?<i args...>?}>

This command gives access to the groups (of all three kinds) in the 
scenario.<p>

<deflist group>

<defitem "group exists" {<i adb> group exists TBD}>
<defitem "group get" {<i adb> group get TBD}>
<defitem "group namedict" {<i adb> group namedict TBD}>
<defitem "group names" {<i adb> group names TBD}>
<defitem "group validate" {<i adb> group validate TBD}>
<defitem "group view" {<i adb> group view TBD}>

</deflist group>


<defitem halt {<i adb> halt}>

Returns athena(n) to the <b PAUSED> state if it is in the 
<b RUNNING> state.  The application can use this if 
athena(n) throws an unexpected error while advancing time.<p>

<defitem hook {<i adb> hook <i subcommand> ?<i args...>?}>

This command gives access to the semantic hooks in the scenario.<p>

<deflist hook>

<defitem "hook exists" {<i adb> hook exists TBD}>
<defitem "hook namedict" {<i adb> hook namedict TBD}>
<defitem "hook names" {<i adb> hook names TBD}>
<defitem "hook topic" {<i adb> hook topic TBD}>
<defitem "hook validate" {<i adb> hook validate TBD}>

</deflist hook>

<defitem idle {<i obj> idle}>

Returns 1 if the scenario is idle, i.e., is ready to accept user input,
and 0 otherwise; see <xref "Scenario States">.<p>

<defitem inject {<i adb> inject <i subcommand> ?<i args...>?}>

This command gives access to the Information Ops Message (IOM) injects
in the scenario.<p>

<deflist inject>

<defitem "inject checker" {<i adb> inject checker TBD}>
<defitem "inject exists" {<i adb> inject exists TBD}>
<defitem "inject get" {<i adb> inject get TBD}>
<defitem "inject typenames" {<i adb> inject typenames TBD}>
<defitem "inject validate" {<i adb> inject validate TBD}>

</deflist inject>

<defitem interrupt {<i obj> interrupt}>

If the scenario <iref isbusy> with a task that is <iref interruptible>,
this command will attempt to interrupt it, causing it to terminate 
prematurely; see <iref busy set> for how to specify that the scenario
is doing an interruptible task.<p>

<defitem interruptible {<i obj> interruptible}>

Returns 1 if the scenario <iref isbusy> with an interruptible task,
and 0 otherwise.<p>

<defitem iom {<i adb> iom <i subcommand> ?<i args...>?}>

This command gives access to the Information Ops Message (IOM) objects
in the scenario.<p>

<deflist iom>

<defitem "iom checker" {<i adb> iom checker TBD}>
<defitem "iom exists" {<i adb> iom exists TBD}>
<defitem "iom get" {<i adb> iom get TBD}>
<defitem "iom namedict" {<i adb> iom namedict TBD}>
<defitem "iom names" {<i adb> iom names TBD}>
<defitem "iom normal" {<i adb> iom normal TBD}>
<defitem "iom validate" {<i adb> iom validate TBD}>

</deflist iom>

<defitem is {<i obj> is <i predicate>}>

Returns 1 if the <i predicate> is true and 0 otherwise.  The valid
predicates are as follows:<p>

<deflist is>
<defitem "is advanced" {<i obj> is advanced}>
Returns 1 if the scenario is <iref locked> and its simulation time has
been advanced.<p>

</deflist>

<defitem isbusy {<i obj> isbusy}>

Returns 1 if the scenario is busy, i.e., is performing a task and 
cannot accept user orders, and 0 otherwise; see <xref "Scenario States">.<p>

<defitem load {<i obj> load <i filename>}>

Loads the scenario from the named <tt *.adb> file into this scenario
object, throwing away any previous data.  The scenario must be
<iref idle>.  Afterwards, the scenario will be <i locked> or 
<i unlocked> depending on the loaded data.<p>

If the client depends on <xref "NOTIFIER EVENTS"> to keep its user interface
in sync with the scenario, it should call <iref dbsync> after calling 
<iref load>.<p>

<defitem lock {<i obj> lock}>

Locks the scenario, if the scenario is <iref idle> and <iref unlocked>
and <iref canlock>.  The simulation time can only be advanced while the
scenario is locked.<p>

<defitem locked {<i obj> locked}>

Returns 1 if the scenario is "locked", initialized and ready for a time
advance, and 0 otherwise; see <xref "Scenario States">.<p>

<defitem onecolumn {<i adb> onecolumn <i query>}>

Evaluates an SQL <i query> with respect to the scenario's run-time 
database, returning only the first column of the first row.
Queries that attempt to modify the RDB will be rejected.<p>

<defitem order {<i adb> order <i subcommand> ?<i args...>?}>

This command gives access to the scenario's <xref mars:order_flunky(n)>
object.<p>

The subcommands are TBD.<p>


<defitem paste {<i obj> paste <i subcommand> ?<i args...>?}>

Pastes copied items into scenario, where the subcommand determines the 
kind of item to paste.  In each case, the paste is done as a sequence of 
grouped orders, and will be undone and redone as a group.<p>

TBD: specify how you get copysets.<p>

The available subcommands are as follows:<p>

<deflist paste>

<defitem "paste block" {<i obj> paste block <i agent copysets>}>

Pastes <i copysets>, a list of copied strategy blocks, into the strategy
owned by the named <i agent>.<p>

<defitem "paste condition" {<i obj> paste condition <i block_id copysets>}>

Pastes <i copysets>, a list of copied conditions, into the strategy block
with the given <i block_id>.<p>

<defitem "paste tactic" {<i obj> paste tactic <i block_id copysets>}>

Pastes <i copysets>, a list of copied tactics, into the strategy block
with the given <i block_id>.<p>

</deflist paste>

<defitem progress {<i obj> progress ?<i value>?}>

Sets and queries the current progress value.  Progress is set while the
scenario <iref isbusy>; see <iref busy set>.  The <i value> may take three
forms:<p>

<topiclist>
<topic {<b user>}>
The user is in control of the scenario.  This would be the case when the
scenario is <i idle> and it <iref isbusy> with something like a wizard GUI,
where normal order entry is suspended until the wizard is closed.
</topic>

<topic {<b wait>}>
The scenario is performing a task of indefinite length, and no actual
progress can be reported until it is done.
</topic>

<topic {<b><i fraction></b>}>
A completion <i fraction> from 0.0 to 1.0.
</topic>
</topiclist><p>

<b TBD>: It might also be good to have a mode for tasks where the duration
cannot be estimated, but many messages are received from the task code.
This would allow a <tt ttk::progressbar> to be animated by the receipt
of these messages instead of automatically, which would give the user
more feedback.<p>


<defitem ptype {<i obj> ptype <i subcommand> ?<i args...>?}>

Parameter type validation subcommands.  This is exposed because it is used by
the Athena Workbench's "view" mechanism.  Ultimately, that should be replaced 
by a gofer-based solution; when that happens, this module can become private.<p>

<defitem query {<i adb> query <i query> ?<i options...>?}>

Evaluates an SQL <i query> with respect to the scenario's run-time 
database, and returns the result set as a formatted string.  The 
<i query> can contain any valid SQL statements understood by SQLite3,
but in practice it will be a single statement that returns a result 
set (i.e., <tt SELECT> or certain <tt PRAGMA> statements).  Queries
that attempt to write to the RDB will be rejected.<p>

The following options may be used:<p>

<deflist query>

<defopt {-mode mc|list|csv}>

Specifies the output mode; the default is <b>mc</b>, multicolumn.<p>

When <tt -mode> is <b>mc</b>, each record is output on a single
line.  Fields are formatted in columns, with the field name as the
column header.<p>

When <tt -mode> is <b>list</b>, the output is a list of records.
Each record is output on multiple lines, with (nominally) one line
per field.  Each line consists of the field name and value; the
record's field names are values are formatted neatly in parallel columns.<p>

When <tt -mode> is <b>csv</b>, the output is in CSV (comma-separated value)
format, one record per line, beginning with a header record of column labels.
Non-numeric values are enclosed in double-quotes.<p>

<defopt {-labels <i>list</i>}>

Normally <iref query> uses the column names found in the query to
label the fields in the output.  If specified, the value of
<b>-labels</b> is a list of labels to be used instead.<p>

<defopt {-maxcolwidth <i>chars</i>}>

Sets the maximum column width, in characters, when <tt -mode> is
<b>mc</b>; the default is 30.  All
data values longer than this will be truncated with "...".<p>

If <b>-maxcolwidth</b> is set to 0 then values will not be
truncated.<p>

<defopt {-headercols <i>num</i>}>

Sets the number of header columns.  When <tt -mode> is <b>mc</b>,
repeated values in a column are skipped.  That is, if a column
contains identical values in consecutive rows, the column will be
blank in all but the first of the rows.  Defaults to "0".<p>

</deflist query>

<defitem rdb {<i adb> rdb <i subcommand> ?<i args...>?}>

This command gives full read/write access to the Run-Time Database (RDB),
a <xref scenariodb(n)> object.  Its write capability is intended for use
in debugging and test; use it with care.<p>

<defitem reset {<i obj> reset}>

Resets the scenario back to its initial empty state.  It will be 
<iref idle> and <i unlocked>.<p>

If the client depends on <xref "NOTIFIER EVENTS"> to keep its user interface
in sync with the scenario, it should call <iref dbsync> after calling 
<iref load>.<p>

<defitem sanity {<i obj> sanity <i subcommand> ?<i args...>?}>

TBD: Sanity-checking module; fill this in.<p>

<defitem save {<i obj> save ?<i filename>?}>

Saves the scenario to disk as an <tt .adb> file called <i filename>,
adding the "<tt .adb>" extension if necessary.  If no <i filename> is
given but the <iref adbfile> name is known, the <iref adbfile> name is
used.  The scenario is marked saved.<p>

On failure, throws "<tt SCENARIO SAVE>".<p>

<defitem state {<i obj> state}>

Returns the scenario's state, which depends on whether or not it is
<iref idle> and whether or not it is <iref locked>.  The states are
<b PREP>, <b PAUSED>, <b BUSY>, and <b RUNNING>; see 
<xref "Scenario States"> for more details.<p>

<defitem statetext {<i obj> statetext}>

Returns a human-readable string that derives from the current 
<iref state>.  If the scenario <iref isbusy>, the string is simply
the <i busytext> passes to <iref busy set>.<p>

<defitem stoptime {<i obj> stoptime}>

While the <i state> is <b RUNNING>, this method returns the simulation
time in weeks at which the simulation will stop and return to the 
<b PAUSED> state.<p>

<defitem unlock {<i obj> unlock}>

Unlocks the scenario, if the scenario is <iref idle> and <iref locked>.
The scenario can only be edited while it is unlocked.<p>

<defitem unlocked {<i obj> unlocked}>

Returns 1 if the scenario is "unlocked", ready for editing, and 0
otherwise; see <xref "Scenario States">.<p>

<defitem unsaved {<i obj> unsaved}>

Returns 1 if there is unsaved scenario data, and 0 otherwise.<p>

<defitem version {<i obj> version}>

Returns the version number of the <xref athena(n)> library.<p>

</deflist instance>

<section FUNCTIONS>

athena(n) defines many SQL functions for use in database queries.  The
functions are TBD.<p>

<section "NOTIFIER EVENTS">

athena(n) and its subcomponents send <xref notifier(n)> events.  Top-level
events are sent by the <tt -subject> indicated when the instance is created.
Individual subcomponents can also send events; in this case, the 
<xref notifier(n)> subject is "<i subject>.<i component>".  If the 
<tt -subject> is "<tt ::adb>", for example, the order flunky component
sends events as "<tt ::adb.flunky>".<p>

<b TBD>: This section should document all notifier events sent by
athena(n), including those by subcomponents.<p>

<deflist events>

<defitem Create {<i subject> <tag Create>}>

The athena(n) instance sends this event on creation, after it is fully
initialized.  This is useful when an application reuses the same 
<tt -subject> for successive scenarios, as it allows GUI modules to 
initialize themselves.<p>

<defitem Destroy {<i subject> <tag Destroy>}>

The athena(n) instance sends this event when it is destroyed.  This allows
client modules to clean up references to the object and its subcomponents.
<p>

</deflist>

<section AUTHOR>

Will Duquette<p>

<section HISTORY>

New package derived from Athena internals.<p>

</manpage>




