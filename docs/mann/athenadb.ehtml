<manpage {athena(n) athenadb(n)} "Athena Private Scenario Type">

<section SYNOPSIS>

<pre>
package require athena <version>
</pre>

<itemlist>

<section DESCRIPTION>

athenadb(n) is a Snit type whose instances represent entire Athena
scenarios.  It is the main type in the <xref athena(n)> library; 
creating an instance of athenadb(n) creates all of the other objects 
required by a scenario.  It is also a utility object for all objects in 
the scenario; it passes itself to all objects it creates, and they use it 
as the primary means of accessing other objects.<p>

athenadb(n) is a <b private> type, to be used only within the library code.
Note that <xref athena(n)>, the public interface to the library, is a thin
wrapper around athenadb(n), providing only the public operations.<p>

<section "COMMANDS">

This module defines the following commands:<p>

<deflist commands>

<defitem "athenadb create" {athenadb create <i name> ?<i options...>?}>

Creates a new instance of athenadb(n) called <i name>, which becomes a 
Tcl command defined in the current scope; <iref athenadb create> returns
the fully-qualified form of the name.<p>


The following options may be used:<p>

<deflist options>

<defopt {-adbfile <i filename>}>

Specifies the name of an Athena scenario (<tt *.adb>) file.  If given,
the file is loaded immediately.<p>

<defopt {-executivecmd <i cmd>}>

A callback command to be used to define application-specific executive
commands.  It is called with on additional argument, the scenario's
<xref executive(n)> component.  This option is read-only after creation.<p>

<defopt {-logcmd <i command>}>

Specifies the name of a command the library code will use to write to
an application log.  athenadb(n) assumes that the <i command> either is
or mimics a <xref mars:logger(n)> object; however, only the 
logger(n) subcommands that output log messages are used.<p>

Log messages produced by athenadb(n) use the <tt -subject> as the 
log component name, possibly qualified by the name of the athenadb(n)
subcomponent producing the message.<p>

<defopt {-scratch <i dirname>}>

Names a scratch directory where athenadb(n) can write debugging files.
Defaults to the current working directory.<p>

<defopt {-subject <i name>}>

Specifies the subject <i name> used for any <xref mars:notifier(n)>
events sent by the object.  By default, the <i name> defaults to the
object's fully-qualified command name.<p>

For example, 
athenadb(n) wraps an <xref mars:sqldocument(n)> object used to contain
the scenario's run-time database (RDB).  When monitoring is enabled, the
RDB can generate <xref mars:notifier(n)> events as tables are updated.<p>


</deflist options>

</deflist commands>

<section "INSTANCE COMMAND">

Each athenadb(n) instance has many subcommands, most of which correspond
to a particular subcomponent; e.g., the <tt civgroup> subcommand corresponds
to the module that handles the editing of civilian group entities.<p>

Because this is a private module, and because the list of such components
changes over time, few of these subcommands will be documented here.  
Other subcommands represent utilities for general use by the library as 
a whole, and these are documented below.<p>

<deflist instance>

<defitem adbfile {<i obj> adbfile}>

Returns the name of the <tt .adb> file loaded on creation, if any, or
the <tt .adb> file name last used for saving, or "" if no <tt .adb> file
has ever been loaded or saved.<p>

<defitem component {<i obj> component <i name>}>

Returns the fully-qualified command name for the named component, so that
it can be passed to other objects that need direct access.  The following
components are accessible:<p>

<deflist components>
<def {clock}>
The instance's simulation clock, a <xref weekclock(n)> object.<p>

<def {rdb}>
The instance's run-time database object, a <xref scenariodb(n)> object.<p>

</deflist components>

<defitem cprofile {<i obj> cprofile ?<i depth>? <i component args...>}>

This is exactly like <iref profile>, but the command to call is an
<xref athenadb(n)> subcomponent called as a subcommand of <i obj>.<p>

<defitem dbsync {<i obj> dbsync}>

Sends out a sequence of notifier events to the client, to be used to
refresh the client when the scenario changes, i.e., after a <iref load>
or <iref reset>.<p>

The sequence is <tt><tag PreSync></tt>, <tt><tag Sync></tt>, 
<tt><tag Time></tt>, and <tt><tag State></tt>.  See <xref athena(n)> for
more about the notifier events sent by the library.<p>

<defitem delete {<i obj> delete ...}>
This command is delegated to the underlying <i scenariodb(n)> object.<p>

<defitem enter {<i obj> enter <i options...>}>

If <iref tkloaded>, then this command is used to pop up order dialogs.
The options are as follows:<p>

<deflist enter>

<defopt {-order <i name>}>

Specifies the order name, e.g., <tt ACTOR:CREATE>.<p>

<defopt {-parmdict <i dict>}>

Specifies a dictionary of order parameter names and values, to be used to
initialize the dialog.<p>

<defopt {-master <i window>}>

Specifies the Tk window over which the dialog should appear.<p>

<defopt {-appname <i name>}>

Specifies the application name for the dialog title.<p>

<defopt {-helpcmd <i cmd>}>

Specifies a command to call if the dialog's help button is pushed.<p>

</deflist enter>

<defitem eval {<i obj> eval ...}>
This command is delegated to the underlying <i scenariodb(n)> object.<p>

<defitem exists {<i obj> exists ...}>
This command is delegated to the underlying <i scenariodb(n)> object.<p>

<defitem grab {<i obj> grab ...}>
This command is delegated to the underlying <i scenariodb(n)> object.<p>

<defitem last_insert_rowid {<i obj> last_insert_rowid}>
This command is delegated to the underlying <i scenariodb(n)> object.<p>

<defitem load {<i obj> load <i filename>}>

Loads the scenario from the named <tt *.adb> file into this scenario
object, throwing away any previous data.<p>

<defitem locked {<i obj> locked}>

Returns 1 if the scenario is "locked", i.e., in the <b PAUSED> or 
<b RUNNING> state.<p>

<defitem monitor {<i obj> monitor ...}>
This command is delegated to the underlying <i scenariodb(n)> object.<p>

<defitem notify {<i obj> notify <i component event> ?<i args...>?}>

Sends a <xref mars:notifier(n)> event on behalf of <xref athena(n)>.  If
the <i component> name is "", then the event is sent by the 
<tt -subject>; otherwise, the <tt -subject> is suffixed with 
"<tt>.<i component></tt>"<p>

<defitem onecolumn {<i obj> onecolumn ...}>
This command is delegated to the underlying <i scenariodb(n)> object.<p>

<defitem order {<i obj> order <i subcommand> ?<i args...>?}>

The subcommands of this command are passed along to the scenario's
"order flunky".  Most subcommands are documented by the
<xref mars:order_flunky(n)> man page; the Athena-specific subcommands
are as follows:<p>

<deflist order>

<defitem "monitor" {<i obj> order monitor ?<i flag>?}>

Sets and queries the monitor flag.  If set, RDB changes taking place
during order execution are monitored, and relevant notifier events are
sent to the application.  See <xref athena(n)> for details.<p>

Defaults to true.<p>

<defitem "transactions" {<i obj> order transactions ?<i flag>?}>

Sets and queries the transaction flag.  If set, all orders are executed
in the context of an SQL transaction; if the order throws an error, the
transaction is rolled back, thus preventing corruption of the RDB.<p>

Defaults to true.<p>

</deflist order>

<defitem paste {<i obj> paste <i subcommand> ?<i args...>?}>

Pastes copied items into scenario, where the subcommand determines the 
kind of item to paste.  In each case, the paste is done as a sequence of 
grouped orders, and will be undone and redone as a group.<p>

The available subcommands are as follows:<p>

<deflist paste>

<defitem "paste block" {<i obj> paste block <i agent copysets>}>

Pastes <i copysets>, a list of copied strategy blocks, into the strategy
owned by the named <i agent>.<p>

<defitem "paste condition" {<i obj> paste condition <i block_id copysets>}>

Pastes <i copysets>, a list of copied conditions, into the strategy block
with the given <i block_id>.<p>

<defitem "paste tactic" {<i obj> paste tactic <i block_id copysets>}>

Pastes <i copysets>, a list of copied tactics, into the strategy block
with the given <i block_id>.<p>

</deflist paste>

<defitem profile {<i obj> profile ?<i depth>? <i command...>}>

Calls the command once using <tt time>, in the caller's context,
and the logs the outcome, returning the commands return value.
In other words, you can prefix any statement with 
"<tt><i obj> profile</tt>" and profile that call without changing code
or adding new routines.<p>

If the <i depth> is given, it must be an integer; that many "*" characters
are added to the beginning of the log message.  This is useful when 
profiling calls within another profiled call.<p>

<defitem query {<i obj> query ...}>
This command is delegated to the underlying <i scenariodb(n)> object.<p>

<defitem reset {<i obj> reset}>

Resets the scenario back to initial empty state.<p>

<defitem safeeval {<i obj> safeeval ...}>
This command is delegated to the underlying <i scenariodb(n)> object.<p>

<defitem safequery {<i obj> safequery ...}>
This command is delegated to the underlying <i scenariodb(n)> object.<p>

<defitem save {<i obj> save ?<i filename>?}>

Saves the scenario to disk as an <tt .adb> file called <i filename>,
adding the "<tt .adb>" extension if necessary.  If no <i filename> is
given but the <iref adbfile> name is known, the <iref adbfile> name is
used.<p>

  On failure, throws "<tt SCENARIO SAVE>".<p>

<defitem schema {<i obj> schema ...}>
This command is delegated to the underlying <i scenariodb(n)> object.<p>

<defitem scratch {<i obj> scratch ?<i args...>?}>

Called with no arguments, returns the <tt -scratch> directory.  Any
arguments are joined to the scratch directory as by <tt file join>, and
the resulting path is returned.<p>

<defitem tables {<i obj> tables ...}>
This command is delegated to the underlying <i scenariodb(n)> object.<p>

<defitem ungrab {<i obj> ungrab ...}>
This command is delegated to the underlying <i scenariodb(n)> object.<p>

<defitem stable {<i obj> stable}>

Returns 1 if the simulation is "stable", i.e., is paused for input, 
and 0 otherwise.  It is stable if the <iref state> is <b PREP> or
<b PAUSED>.<p>

<defitem state {<i obj> state}>

Returns the scenario's simulation state: <b PREP>, <b PAUSED>, <b RUNNING>,
or <b WIZARD>.  <b PREP> is the "scenario preparation" state; the 
scenario may be edited freely.  "Locking" the scenario places it in the
<b PAUSED> state, at which point time may be advanced; while time is 
advancing, it is in the <b RUNNING> state.<p>

The client may place an unlocked scenario in the <b WIZARD> state using
<iref wizlock>; this locks out all changes until the <iref wizlock> is
disabled.  It is used to lock out the normal scenario orders while a 
"wizard" GUI is being used.<p>

<defitem tkloaded {<i obj> tkloaded}>

Returns 1 if Tk is loaded, and 0 otherwise.<p>

<defitem unsaved {<i obj> unsaved}>

Returns 1 if there is unsaved scenario data, and 0 otherwise.<p>

<defitem version {<i obj> version}>

Returns the version number of the <xref athena(n)> library.<p>

</deflist instance>

<section "SQL FUNCTIONS">

athenadb(n) defines many SQL functions for use in database queries.  
See <xref athena(n)> for details.<p>

<section AUTHOR>

Will Duquette<p>

<section HISTORY>

New package derived from Athena internals.<p>

</manpage>




