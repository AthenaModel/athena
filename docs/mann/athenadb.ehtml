<manpage {athena(n) athenadb(n)} "Athena Private Scenario Type">

<section SYNOPSIS>

<pre>
package require athena <version>
</pre>

<itemlist>

<section DESCRIPTION>

athenadb(n) is a Snit type whose instances represent entire Athena
scenarios.  It is the main type in the <xref athena(n)> library; 
creating an instance of athenadb(n) creates all of the other objects 
required by a scenario.  It is also a utility object for all objects in 
the scenario; it passes itself to all objects it creates, and they use it 
as the primary means of accessing other objects.<p>

athenadb(n) is a <b private> type, to be used only within the library code.
Note that <xref athena(n)>, the public interface to the library, is a thin
wrapper around athenadb(n), providing only the public operations.<p>

<section "COMMANDS">

This module defines the following commands:<p>

<deflist commands>

<defitem "athenadb create" {athenadb create <i name> ?<i options...>?}>

Creates a new instance of athenadb(n) called <i name>, which becomes a 
Tcl command defined in the current scope; <iref athenadb create> returns
the fully-qualified form of the name.<p>


The following options may be used:<p>

<deflist options>

<defopt {-adbfile <i filename>}>

Specifies the name of an Athena scenario (<tt *.adb>) file.  If given,
the file is loaded immediately.<p>

<defopt {-executivecmd <i cmd>}>

A callback command to be used to define application-specific executive
commands.  It is called with on additional argument, the scenario's
<xref executive(n)> component.  This option is read-only after creation.<p>

<defopt {-logcmd <i command>}>

Specifies the name of a command the library code will use to write to
an application log.  athenadb(n) assumes that the <i command> either is
or mimics a <xref mars:logger(n)> object; however, only the 
logger(n) subcommands that output log messages are used.<p>

Log messages produced by athenadb(n) use the <tt -subject> as the 
log component name, possibly qualified by the name of the athenadb(n)
subcomponent producing the message.<p>

<defopt {-scratch <i dirname>}>

Names a scratch directory where athenadb(n) can write debugging files.
Defaults to the current working directory.<p>

<defopt {-subject <i name>}>

Specifies the subject <i name> used for any <xref mars:notifier(n)>
events sent by the object.  By default, the <i name> defaults to the
object's fully-qualified command name.<p>

For example, 
athenadb(n) wraps an <xref mars:sqldocument(n)> object used to contain
the scenario's run-time database (RDB).  When monitoring is enabled, the
RDB can generate <xref mars:notifier(n)> events as tables are updated.<p>


</deflist options>

</deflist commands>

<section "INSTANCE COMMAND">

Each athenadb(n) instance has many subcommands, most of which correspond
to a particular subcomponent; e.g., the <tt civgroup> subcommand corresponds
to the module that handles the editing of civilian group entities.<p>

Because this is a private module, and because the list of such components
changes over time, few of these subcommands will be documented here.  
Other subcommands represent utilities for general use by the library as 
a whole, and these are documented below.<p>

<deflist instance>

<defitem rdb {<i obj> rdb <i subcommand...> ?<i args...>?}>       
<defitem eval {<i obj> eval ...}>      
<defitem delete {<i obj> delete ...}>
<defitem exists {<i obj> exists ...}>
<defitem grab {<i obj> grab ...}>
<defitem last_insert_rowid {<i obj> last_insert_rowid}>
<defitem monitor {<i obj> monitor ...}>
<defitem onecolumn {<i obj> onecolumn ...}>
<defitem query {<i obj> query ...}>
<defitem safeeval {<i obj> safeeval ...}>
<defitem safequery {<i obj> safequery ...}>
<defitem schema {<i obj> schema ...}>
<defitem tables {<i obj> tables ...}>
<defitem ungrab {<i obj> ungrab ...}>

These subcommands are delegated to the underlying <i scenariodb(n)> object,
and are used to change and query the run-time database (RDB).<p>

<defitem adbfile {<i obj> adbfile}>

Returns the name of the <tt .adb> file loaded on creation, if any, or
the <tt .adb> file name last used for saving, or "" if no <tt .adb> file
has ever been loaded or saved.<p>

<defitem "component clock" {<i obj> component clock}>

Returns the fully-qualified name of the instance's simulation clock,
a <xref weekclock(n)> object, for direct
use by the wrapping <xref athena(n)> object.<p>

<defitem "component rdb" {<i obj> component rdb}>

Returns the fully-qualified name of the instance's 
<xref scenariodb(n)> handle, for direct
use by the wrapping <xref athena(n)> object.<p>

<defitem cprofile {<i obj> cprofile ?<i depth>? <i component args...>}>

This is exactly like <iref profile>, but the command to call is an
<xref athenadb(n)> subcomponent called as a subcommand of <i obj>.<p>


<defitem dbsync {<i obj> dbsync}>

Sends out a sequence of notifier events to the client, to be used to
refresh the client when the scenario changes, i.e., after a <iref load>
or <iref reset>.<p>

The sequence is <tt><tag PreSync></tt>, <tt><tag Sync></tt>, 
<tt><tag Time></tt>, and <tt><tag State></tt>.  See <xref athena(n)> for
more about the notifier events sent by the library.<p>

<defitem enter {<i obj> enter <i options...>}>

If <iref tkloaded>, then this command is used to pop up order dialogs.
The options are as follows:<p>

<deflist enter>

<defopt {-order <i name>}>

Specifies the order name, e.g., <tt ACTOR:CREATE>.<p>

<defopt {-parmdict <i dict>}>

Specifies a dictionary of order parameter names and values, to be used to
initialize the dialog.<p>

<defopt {-master <i window>}>

Specifies the Tk window over which the dialog should appear.<p>

<defopt {-appname <i name>}>

Specifies the application name for the dialog title.<p>

<defopt {-helpcmd <i cmd>}>

Specifies a command to call if the dialog's help button is pushed.<p>

</deflist enter>

<defitem load {<i obj> load <i filename>}>

Loads the scenario from the named <tt *.adb> file into this scenario
object, throwing away any previous data.<p>

<defitem locked {<i obj> locked}>

Returns 1 if the scenario is "locked", i.e., in the <b PAUSED> or 
<b RUNNING> state.<p>

<defitem notify {<i obj> notify <i component event> ?<i args...>?}>

Sends a <xref mars:notifier(n)> event on behalf of <xref athena(n)>.  If
the <i component> name is "", then the event is sent by the 
<tt -subject>; otherwise, the <tt -subject> is suffixed with 
"<tt>.<i component></tt>"<p>

<defitem order {<i obj> order <i subcommand> ?<i args...>?}>

The subcommands of this command are passed along to the scenario's
"order flunky".  They are as follows:

<deflist order>

<defitem "order available" {<i obj> order available ...}>
<defitem "order canredo" {<i obj> order canredo}>
<defitem "order canundo" {<i obj> order canundo}>
<defitem "order class" {<i obj> order class ...}>
<defitem "order execute" {<i obj> order execute ...}>
<defitem "order exists" {<i obj> order exists ...}>
<defitem "order make" {<i obj> order make ...}>
<defitem "order names" {<i obj> order names}>
<defitem "order redo" {<i obj> order redo}>
<defitem "order redotext" {<i obj> order redotext}>
<defitem "order reset" {<i obj> order reset}>
<defitem "order send" {<i obj> order send ...}>
<defitem "order senddict" {<i obj> order senddict...}>
<defitem "order state" {<i obj> order state ...}>
<defitem "order transaction" {<i obj> order transaction ...}>
<defitem "order undo" {<i obj> order undo}>
<defitem "order undotext" {<i obj> order undotext}>
<defitem "order validate" {<i obj> order validate ...}>

These commands are defined by the <xref mars:order_flunky(n)> class;
see that man page for details.<p>

<defitem "monitor" {<i obj> order monitor ?<i flag>?}>

Sets and queries the monitor flag.  If set, RDB changes taking place
during order execution are monitored, and relevant notifier events are
sent to the application.  See <xref athena(n)> for details.<p>

Defaults to true.<p>


<defitem "transactions" {<i obj> order transactions ?<i flag>?}>

Sets and queries the transaction flag.  If set, all orders are executed
in the context of an SQL transaction; if the order throws an error, the
transaction is rolled back, thus preventing corruption of the RDB.<p>

Defaults to true.<p>

</deflist order>

<defitem paste {<i obj> paste <i subcommand> ?<i args...>?}>

Pastes copied items into scenario, where the subcommand determines the 
kind of item to paste.  In each case, the paste is done as a sequence of 
grouped orders, and will be undone and redone as a group.<p>

The available subcommands are as follows:<p>

<deflist paste>

<defitem "paste block" {<i obj> paste block <i agent copysets>}>

Pastes <i copysets>, a list of copied strategy blocks, into the strategy
owned by the named <i agent>.<p>

<defitem "paste condition" {<i obj> paste condition <i block_id copysets>}>

Pastes <i copysets>, a list of copied conditions, into the strategy block
with the given <i block_id>.<p>

<defitem "paste tactic" {<i obj> paste tactic <i block_id copysets>}>

Pastes <i copysets>, a list of copied tactics, into the strategy block
with the given <i block_id>.<p>

</deflist paste>

<defitem profile {<i obj> profile ?<i depth>? <i command...>}>

Calls the command once using <tt time>, in the caller's context,
and the logs the outcome, returning the commands return value.
In other words, you can prefix any statement with 
"<tt><i obj> profile</tt>" and profile that call without changing code
or adding new routines.<p>

If the <i depth> is given, it must be an integer; that many "*" characters
are added to the beginning of the log message.  This is useful when 
profiling calls within another profiled call.<p>


<defitem reset {<i obj> reset}>

Resets the scenario back to initial empty state.<p>

<defitem save {<i obj> save ?<i filename>?}>

Saves the scenario to disk as an <tt .adb> file called <i filename>,
adding the "<tt .adb>" extension if necessary.  If no <i filename> is
given but the <iref adbfile> name is known, the <iref adbfile> name is
used.<p>

  On failure, throws "<tt SCENARIO SAVE>".<p>

<defitem scratch {<i obj> scratch ?<i args...>?}>

Called with no arguments, returns the <tt -scratch> directory.  Any
arguments are joined to the scratch directory as by <tt file join>, and
the resulting path is returned.<p>

<defitem stable {<i obj> stable}>

Returns 1 if the simulation is "stable", i.e., is paused for input, 
and 0 otherwise.  It is stable if the <iref state> is <b PREP> or
<b PAUSED>.<p>

<defitem state {<i obj> state}>

Returns the scenario's simulation state: <b PREP>, <b PAUSED>, <b RUNNING>,
or <b WIZARD>.  <b PREP> is the "scenario preparation" state; the 
scenario may be edited freely.  "Locking" the scenario places it in the
<b PAUSED> state, at which point time may be advanced; while time is 
advancing, it is in the <b RUNNING> state.<p>

The client may place an unlocked scenario in the <b WIZARD> state using
<iref wizlock>; this locks out all changes until the <iref wizlock> is
disabled.  It is used to lock out the normal scenario orders while a 
"wizard" GUI is being used.<p>

<defitem stoptime {<i obj> stoptime}>

While the <i state> is <b RUNNING>, this method returns the simulation
time in weeks at which the simulation will stop and return to the 
<b PAUSED> state.<p>

<defitem tkloaded {<i obj> tkloaded}>

Returns 1 if Tk is loaded, and 0 otherwise.<p>

<defitem unsaved {<i obj> unsaved}>

Returns 1 if there is unsaved scenario data, and 0 otherwise.<p>

<defitem version {<i obj> version}>

Returns the version number of the <xref athena(n)> library.<p>

<defitem wizlock {<i obj> wizlock <i flag>}>

Sets or clears the "wizard lock" flag, which is used to lock out 
changes to the scenario while a wizard GUI is running.  The wizard
itself will typical set the <i flag> when it starts, and clear it
just prior to sending a sequence of orders in an <iref order transaction>.
The wizard lock flag may only be set when <iref state> is <b PREP>, and
functions by setting the <iref state> to <b WIZARD>.<p>


</deflist instance>

<section FUNCTIONS>

athena(n) defines many SQL functions for use in database queries.  The
functions are TBD.<p>

<section AUTHOR>

Will Duquette<p>

<section HISTORY>

New package derived from Athena internals.<p>

</manpage>




