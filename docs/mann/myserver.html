<html>
<head>
<title>athena 6.3.0a7: myserver(n) -- Basic myserver(i) Server, submodule of projectlib(n)</title>
<style type="text/css" media="screen,print">

        A {
            text-decoration: none;
        }

        TABLE {
            margin-top:    4px;
            margin-bottom: 4px;
        }

        TR {
            vertical-align: baseline;
        }

        TH {
            padding-left: 4px;
        }

        TD {
            padding-left: 4px;
        }

        /* Table Formatting Classes: "pretty" 
         * Border around the outside, even/odd striping, no internal
         * border lines.
         */
        TABLE.pretty {
            border: 1px solid black;
            border-spacing: 0;
        }

        TABLE.pretty TR.header {
            font-weight: bold;
            color: white;
            background-color: #000099;
        }

        TABLE.pretty TR.oddrow {
            color: black;
            background-color: white;
        }

        TABLE.pretty TR.evenrow {
            color: black;
            background-color: #EEEEEE;
        }

        /* Examples, listings, and marks */
        PRE.example {
            background:     #FFFDD1 ;
            border:         1px solid blue;
            padding-top:    2px;
            padding-bottom: 2px;
            padding-left:   4px;
        }

        PRE.listing {
            background:     #FFFDD1 ;
            border:         1px solid blue;
            padding-top:    4px;
            padding-bottom: 4px;
            padding-left:   4px;
        }

        SPAN.linenum {
            background:     #E3E08F ;
        }

        DIV.mark {
            display: inline;
            font-family: Verdana;
            font-size: 75%;
            background: black;
            color: white;
            border: 1px solid black;
            border-radius: 5px;
            padding-left: 2px;
            padding-right: 2px;
        }

        DIV.bigmark {
            display: inline;
            font-family: Verdana;
            font-size: 100%;
            background: black;
            color: white;
            border: 1px solid black;
            border-radius: 5px;
            padding-left: 2px;
            padding-right: 2px;
        }

        /* Topic Lists. */
        TR.topic {
            vertical-align: baseline;
        }

        TR.topicname {
            min-width: 1.5em;
        }

    

        BODY {
            color: black;
            background: white;
            margin-left: 6%;
            margin-right: 6%;
        }

        H1 {
            margin-left: -5%;
        }
        H2 {
            margin-left: -5%;
        }
        HR {
            margin-left: -5%;
        }

        TABLE {
            text-align:    left;
        }
        
        /* mktree styles */
        ul.mktree  li  { list-style: none; }
        ul.mktree, ul.mktree ul, ul.mktree li { 
            margin-left:10px; padding:0px; }
        ul.mktree li .bullet { padding-left: 10px }
        ul.mktree  li.liOpen   .bullet {cursor : pointer; }
        ul.mktree  li.liClosed .bullet {cursor : pointer; }
        ul.mktree  li.liBullet .bullet {cursor : default; }
        ul.mktree  li.liOpen   ul {display: block; }
        ul.mktree  li.liClosed ul {display: none; }
    
</style>



</head>

<body>
<h1 style="background: red;">
&nbsp;athena 6.3.0a7: Athena Regional Stability Simulation
</h1>
    

<h2><a name="name">NAME</a></h2>
    

<b>myserver(n)</b> -- Basic myserver(i) Server, submodule of <a href="../mann/projectlib.html">projectlib(n)</a>

<ul>

    <li><a href="#name">NAME</a></li>
    

    <li><a href="#synopsis">SYNOPSIS</a></li>
    

    <li><a href="#description">DESCRIPTION</a></li>
    

    <li><a href="#content_types">CONTENT TYPES</a></li>
    

    <li><a href="#commands">COMMANDS</a></li>
    

    <li><a href="#instance_commands">INSTANCE COMMANDS</a></li>
    

    <li><a href="#environment">ENVIRONMENT</a></li>
    

    <li><a href="#author">AUTHOR</a></li>
    

    <li><a href="#history">HISTORY</a></li>
    

</ul>
    
    

<h2><a name="synopsis">SYNOPSIS</a></h2>
    

<pre>
package require projectlib 6.3.0a7
namespace import ::projectlib::myserver
</pre>

<tt><a href="#text/html">text/html</a></tt><br>

<tt><a href="#myserver">myserver <i>name</i> ?<i>option value...</i>?</a></tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;
<tt><a href="#myserver-logcmd">-logcmd <i>cmd</i></a></tt><br>


<tt><a href="#ctypes">$server ctypes <i>rtype</i></a></tt><br>

<tt><a href="#get">$server get <i>url</i> ?<i>contentTypes</i>?</a></tt><br>

<tt><a href="#url">url</a></tt><br>

<tt><a href="#contenttype">contentType</a></tt><br>

<tt><a href="#content">content</a></tt><br>

<tt><a href="#register">$server register <i>rtype pattern ctype handler</i>
?<i>ctype handler...</i>? <i>doc</i>
</a></tt><br>

<tt><a href="#resources">$server resources</a></tt><br>

<p>
    

<h2><a name="description">DESCRIPTION</a></h2>
    

myserver(n) is a basic <a href="../mani/myserver.html">myserver(i)</a> implementation.
The application creates an instance of myserver(n) and registers
resources and resource handlers with it; it then registers the
instance with <a href="../mann/myagent.html">myagent(n)</a>.  At that point, <a href="../mann/myagent.html">myagent(n)</a>
clients like <a href="../mann/mybrowser.html">mybrowser(n)</a> can query it.<p>

The only resources known to a newly created myserver(n) are
<code>/urlhelp</code> and <code>/urlhelp/{url}</code>, which are used
to browse the set of resources known to the server.<p>

<h2><a name="content_types">CONTENT TYPES</a></h2>
    

By default, myserver(n) serves only the following content types<p>

<dl>

<dt><b><tt><a name="text/html">text/html</a></tt></b></dt>
<dd>
    

HTML text.<p>

However, registered resource handlers can provide content in any
desired form; myserver(n) doesn't care.<p>

</dl>

<h2><a name="commands">COMMANDS</a></h2>
    

myserver(n) provides the following commands for use by the
application.<p>

<dl>

<dt><b><tt><a name="myserver">myserver <i>name</i> ?<i>option value...</i>?</a></tt></b></dt>
<dd>
    

Creates a new instance of myserver(n) called <i>name</i>; returns the
fully-qualified command name.<p>

Instances of myserver(n) take the following options:<p>

<dl>
<dt><b><tt><a name="myserver-logcmd">-logcmd <i>cmd</i></a></tt></b></dt>
<dd>
    
Defines a command prefix to be called with three additional arguments
when the instance wishes to write to the debugging log: a verbosity
level, a module name, and a log message.  Note that <i>cmd</i> will
often be a <a href="../../../mars/docs/mann/logger.html">logger(n)</a> instances.<p>

The most important thing logged by myserver(n) are the requested URLs
and the time (in microseconds) required to produce the content.<p>

</dl>

</dl>


<h2><a name="instance_commands">INSTANCE COMMANDS</a></h2>
    

Instances of myserver(n) provide the following subcommands for use by
the application.<p>

<dl>

<dt><b><tt><a name="ctypes">$server ctypes <i>rtype</i></a></tt></b></dt>
<dd>
    

Given a resource type name, <i>rtype</i>, returns a list of the
available content types.<p>

<dt><b><tt><a name="get">$server get <i>url</i> ?<i>contentTypes</i>?</a></tt></b></dt>
<dd>
    

<b>From <a href="../mani/myserver.html">myserver(i)</a>:</b> Retrieves the <i>url</i> from the
server.  If the <i>url</i> cannot be retrieved for any reason, the
server throws an error with error code <b>NOTFOUND</b>; the error
message is a human-readable message explaining why the resource cannot
be found.<p>

The <i>contentTypes</i> argument, if given, is a list of content types
accepted by the client.  Browse the server's <code>/urlhelp</code> resource
to see what URLs are accepted, and what content types they can
provide.  Custom content types should be documented by the application.<p>

If <i>contentTypes</i> is empty, the server will return the first
available content type for the requested <i>url</i>.  Otherwise, it
will return the first content type listed in <i>contentTypes</i> which
is available for the requested <i>url</i>.<p>

Note that the content types listed in <i>contentTypes</i> can include
wild cards, e.g., <b>text/*</b> and <b>*/*</b>.<p>

On success, the <tt><a href="#get">get</a></tt> command returns a dictionary with the
following keys:<p>

<dl>

<dt><b><tt><a name="url">url</a></tt></b></dt>
<dd>
    

The complete URL given to the server.  This is of interest because the
<a href="../mann/myagent.html">myagent(n)</a> might have performed address resolution; hence,
the URL given to the server might not be the same as the URL given to
the agent.<p>

<dt><b><tt><a name="contenttype">contentType</a></tt></b></dt>
<dd>
    

The content type of the returned content.<p>

<dt><b><tt><a name="content">content</a></tt></b></dt>
<dd>
    

The returned content itself.

</dl>

<dt><b><tt><a name="register">$server register <i>rtype pattern ctype handler</i>
?<i>ctype handler...</i>? <i>doc</i>
</a></tt></b></dt>
<dd>
    

Registers (or re-registers) a resource type with the server; clients
can now query resources of this type.<p>

The <i>rtype</i> is the resource type name.  Resource type names are
arbitrary strings; conventionally, however, they mimic the associated
URL, beginning with a "/", and with placeholder parameter names in
curly brackets.  For example, the resource type for a piece of data
with a given ID might be

<pre>
    /data/{id}
</pre>

The <i>pattern</i> is a regular expression that matches the "path"
component of the resource's URL. It will be used as
"<code>^<i>pattern</i>$</code>" so
that it matches the entire path.  It should not begin with a
"/", as the leading slash is really a separator between the host name
and the path.<p>

The resource can be associated with multiple content types; each
<i>ctype</i> requires a <i>handler</i> to produce the content
associated with that <i>ctype</i>.  At least one <i>ctype</i> and
<i>handler</i> are required.<p>

Use standard MIME content types where possible (e.g.,
<code>text/html</code>, <code>text/plain</code>); for custom content
types containing Tcl-formatted data, use content type names like
<code>tcl/<i>name</i></code> or <code>tk/<i>name</i></code>.  The
application should document all custom content types.<p>

The <i>handler</i> should be a command prefix taking two additional
arguments, the <i>udict</i> and the <i>matchArray</i>.  The
<i>udict</i> is a dictionary of URL components for the URL used to query
the resource, as returned by <code>uri::split</code>, with the entire
<b>url</b> added.  The <i>matchArray</i> is the name of an 
array of pattern matches with indices 0 through 9.  Match 0 is the
entire path component of the URL; matchs 1 through 9 are submatches,
as determined by parentheses in the <i>pattern</i>.<p>

The handler must either return the desired content, or throw a
NOTFOUND error with a human-readable error message.<p>

<dt><b><tt><a name="resources">$server resources</a></tt></b></dt>
<dd>
    

Returns a list of the names of the registered resource types.<p>

</dl>

<h2><a name="environment">ENVIRONMENT</a></h2>
    

Requires Tcl 8.5 or later.<p>

<h2><a name="author">AUTHOR</a></h2>
    

Will Duquette<p>

<h2><a name="history">HISTORY</a></h2>
    

Original package.

<hr>
<i>athena 6.3.0a7 Man page generated by manpage(n) on 
Thu Mar 12 11:50:52 PDT 2015</i>
</body>
</html>
    






