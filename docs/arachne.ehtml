<document "Arachne Interface Specification">

<b NOTE:> This is a preliminary specification; the Arachne executable
is an incomplete prototype.<p>

<hrule>

<contents>

<hrule>

<preface changelog "Change Log">

<changelog>

<change 6/2/2015 Update will>
Updates on the RESTful API, prior to June engineering delivery.<p>
</change>

<change 4/10/2015 Update will>
Added details about the RESTful API.  Also, Arachne is no longer 
intended for non-server batch runs; <xref athena(1)>'s "build" subcommand
handles that use-case quite nicely.<p>
</change>

<change 4/2/2015 Update will>
Added the <tt -web> option, which causes the web server to be started;
the <tt -port> now defaults to 8080.
</change>

<change 2/3/2015 Update will>
<ul>
<li> Arachne assumes all incoming HTTP requests use "https".
     (<xref restapi>).
<li> Added <tt -heartbeat>, <tt -heartbeaturl> options.
</ul>
</change>

<change 1/28/2015 Update will>
Preliminary draft
</change>
</changelog>

<hrule>

<section overview "Overview">

Arachne is a version of Athena intended to run as part of a web back-end in
the cloud.  It includes a web server that provides a RESTful interface
to Athena's run-time data.<p>

The purpose of this document is to specify Arachne's command-line and
RESTful interface as an aid to web developers using Arachne in 
production.<p>

<b NOTE:> Arachne is still in development; therefore this document also 
serves to capture the preliminary design and to record decisions made in
discussions with the Web Athena developers.<p>

<section overview.cloud "Cloud Assumptions">

Arachne makes the following assumptions about its run-time environment when
run as part of the "Web Athena" back end:<p>

<ul>
<li> Arachne runs on a cloud node, with an instance of Arachne for each
     user session.
<li> The node runs 64-bit Linux (this is negotiable).
<li> Arachne is invoked on the node by a wrapper provided by the 
     web-development team.
<li> The wrapper communicates with Arachne by means of its 
     command line and its RESTful HTTP interface.
<li> Arachne is insulated from the outside network by the wrapper 
     (so as to minimize potential security issues).  In other words,
     the wrapper serves as a proxy server between Arachne and the
     front end.
<li> The wrapper handles file management, i.e., it is responsible
     for copying user scenario data to and from the scenario archive,
     whereever that might be.
</ul>

<section overview.name "Why Arachne?">

In Greek myth, Arachne was so skilled at spinning thread that she beat
Athena in a fair contest.  In retaliation, Athena turned Arachne into a 
spider.  Arachne is therefore Athena's web-spinner.<p>

<section cmdline "Command Line Interface">

<b TBD>: This is, of course, quite preliminary.<p>

Arachne is installed as a Linux executable called <b><tt arachne></b>.
It runs as a server with a RESTful web interface.<p>

To run Arachne simply invoke it, optionally specifying the HTTP 
<tt -port> and other options.  Arachne will load 
any <tt -scenario> and execute any <tt -script> for its "base" case, 
and then wait for instructions via HTTP.<p>

To invoke Arache without starting the HTTP server, pass the 
<tt -test> option.  (This is provided as an aid to testing.)<p>

Arachne takes the following command-line options:<p>

<deflist options>

<def {-heartbeat <i seconds>}>

<b Not Yet Implemented.>  Specifies the number of seconds between 
heartbeats.<p>

<def {-heartbeatfile <i filepath>}>

<b Not Yet Implemented.>  If given, and if Arachne is listening for HTTP 
requests, it will write the 
current time in seconds to the named <i filepath> approximately every 
<tt -heartbeat> seconds.  This allows the enclosing web application to be 
sure that it is alive.<p>

<def {-heartbeaturl <i url>}>

<b Not Yet Implemented.>  If given, and if Arachne is listening for 
HTTP requests, it will GET the
specified URL approximately every <tt -heartbeat> seconds.  This allows the 
enclosing web application to be sure that it is alive.<p>

<def {-port <i portid>}>

Specifies the port ID at which Arachne should listen for HTTP requests.
Defaults to port 8080.
<b TBD:> Ultimately, Arachne will accept only HTTPS request; at present,
we are waiting on a bug fix in the Tcl TLS package, so we listen for 
normal HTTP requests.<p>

<def {-scenariodir <i dirpath>}>
Specifies the name of a directory from which Arachne will import and 
export Athena scenario (.adb) files and scenario script (.tcl) files at 
run-time.  The larger application can stage and retrieve files using
this directory.<p>

<def {-scenario <i filename>}>

Specifies the path to an Athena scenario (.adb) file to load at start-up
as Arachne's base case, "<tt case00>".  It is usual to begin with a base 
scenario and then run excursions from it via the RESTful API.  The 
<i filename> must be a bare filename in the <tt -scenariodir>.<p>

If no <tt -scenario> is specified, then Arachne creates an empty scenario
for "<tt case00>".<p>

<def {-script <i filepath>}>

Specifies the path to an Athena script (.tcl) file to load into the
base case at start-up. Any <tt -scenario> is loaded into "<tt case00>" 
first.<p> 

<def {-test}>

If this option is specified, Arachne will halt immediately after loading the
<tt -scenario> and executing the <tt -script>.  This is provided as an
aid to testing.<p>

</deflist options>

<section scenario "Scenario Management">

Arachne allows the client to work with multiple scenarios at one time.
The expected use case is that one scenario will be the "base case" and
the others will be excursions from that base case; but while Arachne
facilitates this pattern it does not require it, and the loaded scenarios
can be entirely unrelated.<p>

<section scenario.caseid "Scenario Case IDs">

Each scenario has a symbolic "case ID" and a human-readable "long name".
The case IDs are strings matching the pattern "<tt>case<i nn></tt>", 
where <i nn> is a number from "00" to "99" (or larger).  
Case IDs are assigned automatically as scenarios are created, cloned, or
imported.  The long name may be set to any desired string.<p>

The base case would typically be scenario <tt case00>, which is created
automatically when Arachne is invoked.<p>

<section scenario.staging "Scenario Staging">

Arachne does not know the details of how users' scenario files will be 
stored or accessed in the cloud.  Consequently, all scenario data is
staged through Arachne's "scenario directory".  The scenario directory
may contain Athena scenarios as scenario files (".adb") or as 
executive script files (".tcl").<p>

Scenarios to be used in Arachne should be copied to the scenario directory
and then <b imported> into a running instance of Arachne using the
<tt /scenario/import.{json,html}> URL.  On import, the client can specify
the scenario's long name.  The newly imported scenario will have a new
case ID, or alternatively, it can be imported over an existing case ID.<p>

Similarly, a scenario to be saved to the closed must be <b exported> to the 
scenario directory using the <tt /scenario/export.{json,html}> URL.  The
client specifies the file name to use, and is then responsible for
storing the file in the cloud.<p>

<section scenario.create "Creating Scenarios">

In addition to importing scenarios, they can also be created within 
Arachne.  The client can create a <b new> empty scenario using
<tt /scenario/new.{json,html}>, and can <b clone> an existing scenario
using <tt /scenario/clone.{json,html}>.<p>

<section scenario.modify "Modifying Scenarios">

Once a scenario has been created, cloned, or imported it can be modified
by sending it orders using <tt>/scenario/<i case>/order.{html,json}</tt>
or executive scripts using <tt>/scenario/<i case>/script.{html,json}</tt>.<p>

<section scenario.other "Other Operations">

Finally, scenarios can be sanity checked, locked, advanced in time, 
queried, and unlocked using the remaining 
<tt /scenario> domain URLs; see <xref restapi.scenario>.<p>


<section restapi "RESTful API">

<section restapi.overview "Overview">

Arachne's RESTful HTTP interface is accessed at
<tt>http://127.0.0.1:<i portid>/</tt>.  The <i portid> is set using
the <tt -port> command line option, and defaults to port 8080.<p>

The HTTP interface can only be accessed from the local host, i.e.,
by the wrapper software, because Arachne doesn't support any kind
of user authentication.<p>

The set of URLs and HTTP operations supported by Arachne is still 
<b TBD>, but will certainly allow all of the following:<p>

<ul>
<li> Controlling scenario execution.
<li> Retrieving overall status information.
<li> Sending Athena executive scripts to Arachne.
<li> Sending Athena orders to Arachne (possibly as scripts)
<li> Requesting run-time results from Arachne
<li> Comparing two scenarios (or one scenario at different times) to
     determine significant deltas.
<li> Requesting explanations of significant deltas in terms of 
     chains of causality. 
</ul> 

Normal requests should be sent as GET requests; form submissions
should be sent using POST.<p>

Information will be returned to the client as HTML or JSON text.  At
present, we assume that the front-end will do most of its own presentation,
and that the HTML will primarily be for debugging.  The return type of
a URL is indicated by the file extension on the URL, e.g., 
".html" or ".json".<p>

<section restapi.help "/help Domain">

We have made the Athena Workbench's on-line help database available via
the Arachne server because it contains quite of bit of information that
will be useful to the front-end developer, including order definitions
and executive script documentation.  Ultimately we plan to provide an
Arachne-specific help database.<p>

The root of the help pages is at 
<tt><link /help/index.html /help/index.html></tt>.<p>

The <tt /help> domain supports full text search; to make use of it, use 
the URL<p>

<example>/help/?search=<i target></example>

In fact, this query string can be used on any page in the <tt /help> 
domain.<p>

<section restapi.scenario "/scenario Domain">

Most of Arachne's URLs reside in the <tt scenario> domain.  Top-level
functionality hangs directly from <tt /scenario>; for example, 
<link /scenario/index.html /scenario/index.html> lists all of the currently
loaded scenarios.<p>

URLs specific to a particular scenario appear in the 
<tt>/scenario/<i case>/</tt> subdomain, where <i case> the scenario's
"case ID".<p>

For a complete list of URLs in this domain, with documentation, see 
<tt><link /scenario/urlschema.html /scenario/urlschema.html></tt>.<p>

<section restapi.json "JSON Conventions">

All URLs that return JSON content end in a file name with extension
"<tt .json>".  In many cases, the result is simply the JSON object or 
list.  

In cases where error returns are possible (e.g., when using
the JSON interface to perform some action, or when invalid query 
parameters are sent) the JSON result is a list of 
two or three elements.  The first element is a
code, "OK", "ERROR", "REJECT", or "EXCEPTION".<p>

<ul>
<li>  If the code is "OK", the request was
      accepted; the second element is the request's result string, 
      which is often empty, but may be a JSON return value.  Look up the
      particular URL in the 
      <link /scenario/urlschema.html "URL Schema"> for specifics.<p>

<li> If the code is "REJECT", the request was rejected because of input
     errors.  The second 
     element is a JSON object with one field for each problem parameter
     in the request.  The field names are query parameter names 
     (or "*" for errors affecting the whole request); the field values 
     are error messages for display to the user.<p>

<li> If the code is "ERROR", there was an error while processing
     the request.  The second element is an error message.  An "ERROR"
     usually implies that the input parameters were OK but the request
     could not be performed successfully for some other reason.<p>

<li> If the code is "EXCEPTION", there was an unexpected error while executing
     the request.  The second element is an error message, and the third
     element is a TCL stack trace.<p>
</ul>


<section orders "Athena Order Definitions">

The RESTful interface allows Athena orders to be sent to a particular
scenario; thus, the order definitions are part of the 
interface specification.  We already have high-quality documentation of
all Athena orders as on-line help in the Athena Workbench; for now,
we are making this same help database available through Arachne's web 
interface, at <tt><link /help/index.html /help/index.html></tt>.<p>

In time, we hope to provide a help database tailored to the Arachne 
user.  In addition, the Athena Workbench has a sophisticated set of
infrastructure for creating interactive data entry forms from order
definitions.  At present, this infrastructure only works with TK GUIs,
not with web UIs.  We plan to extend this "dynaform" infrastructure to 
work with web forms as well, so as to reduce the burden on the web
developers and to make order modifications in the back-end 
require minimal (or zero) changes to the front-end.<p>

<section script "Athena Script Commands">

The RESTful interface allows executive scripts to be sent to a particular
scenario and executed by it; thus, the executive commands are part of the 
interface specification.  We already have high-quality documentation of
the executive commands as on-line help in the Athena Workbench; for now,
we are making this same help database available through Arachne's 
web interface, at <tt><link /help/index.html /help/index.html></tt>.<p>

In time, we hope to provide a help database tailored to the 
Arachne user.<p>

</document>


