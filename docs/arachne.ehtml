<document "Arachne Interface Specification">

<b NOTE:> This is a preliminary specification; the Arachne executable
is an incomplete prototype.<p>

<hrule>

<contents>

<hrule>

<preface changelog "Change Log">

<changelog>

<change 4/6/2015 Update will>
Added details about the RESTful API.<p>
</change>

<change 4/2/2015 Update will>
Added the <tt -web> option, which causes the web server to be started;
the <tt -port> now defaults to 8080.
</change>

<change 2/3/2015 Update will>
<ul>
<li> Arachne assumes all incoming HTTP requests use "https".
     (<xref restapi>).
<li> Added <tt -heartbeat>, <tt -heartbeaturl> options.
</ul>
</change>

<change 1/28/2015 Update will>
Preliminary draft
</change>
</changelog>

<hrule>

<section overview "Overview">

Arachne is a version of Athena intended to run as part of a web back-end in
the cloud.  It is a non-GUI version intended to run in batch mode, given
scripts; it also includes a web server that provides a RESTful interface
to Athena's run-time data.<p>

The purpose of this document is to specify Arachne's command-line and
RESTful interface as an aid to web developers using Arachne in 
production.<p>

<b NOTE:> Arachne is still in development; therefore this document also 
serves to capture the preliminary design and to record decisions made in
discussions with the Web Athena developers.<p>

<section overview.cloud "Cloud Assumptions">

Arachne makes the following assumptions about its run-time environment when
run as part of the "Web Athena" back end:<p>

<ul>
<li> Arachne runs on a cloud node, with an instance of Arachne for each
     user session.
<li> The node runs 64-bit Linux (this is negotiable).
<li> Arachne is invoked by the back end software on need.
<li> Arachne communicates with the back end software by means of its 
     command line and RESTful HTTP interface.
<li> Arachne is insulated from the outside network by the enclosing back
     end software (so as to minimize potential security issues).
<li> The enclosing software handles file management, i.e., archiving of 
     Athena scenario results.
</ul>

<section overview.name "Why Arachne?">

In Greek myth, Arachne was so skilled at spinning thread that she beat
Athena in a fair contest.  In retaliation, Athena turned Arachne into a 
spider.  Arachne is therefore Athena's web-spinner.<p>

<section cmdline "Command Line Interface">

<b TBD>: This is, of course, quite preliminary.<p>

Arachne is installed as a Linux executable called <b><tt arachne></b>.
It can run as a simple batch-mode version of Athena, or as an interactive
application with a RESTful web interface.<p>

To run Arachne with its RESTful interface, pass it the <tt -web> option,
optionally specifying the HTTP <tt -port>, <tt -public>, and 
<tt -heartbeatfile>.  Arachne will load any <tt -scenario> and execute 
any <tt -script>, and then wait for 
instructions via HTTP.<p>

To run Arachne as a batch-mode application, specify the <tt -scenario>
and <tt -script> but do not specify <tt -web>.  The RESTful interface
will not be initialize; instead, Arachne will load the <tt -scenario> and
run the <tt -script> and the halt.<p>

Arachne takes the following command-line options:<p>

<deflist options>

<def {-heartbeat <i seconds>}>

<b Not Yet Implemented.>  Specifies the number of seconds between 
heartbeats.<p>

<def {-heartbeatfile <i filepath>}>

<b Not Yet Implemented.>  If given, and if Arachne is listening for HTTP 
requests, it will write the 
current time in seconds to the named <i filepath> approximately every 
<tt -heartbeat> seconds.  This allows the enclosing web application to be 
sure that it is alive.<p>

<def {-heartbeaturl <i url>}>

<b Not Yet Implemented.>  If given, and if Arachne is listening for 
HTTP requests, it will GET the
specified URL approximately every <tt -heartbeat> seconds.  This allows the 
enclosing web application to be sure that it is alive.<p>

<def {-public}>

By default, Arachne only accepts HTTP requests from the local host.  If
this option is given, Arachne will accept HTTP requests from other hosts.<p>

<def {-port <i portid>}>

Specifies the port ID at which Arachne should listen for HTTP requests.
Defaults to port 8080.<p>

<def {-scenariodir <i dirpath>}>
Specifies the name of a directory in which to store and look for 
Athena scenario (.adb) files and scenario script (.tcl) files at 
run-time.<p>

<def {-scenario <i filepath>}>

Specifies the path to an Athena scenario (.adb) file to load at start-up.
It is usual to begin with a base scenario and then run excursions from it
via the RESTful API, although this can also be scripted.<p>

<def {-script <i filepath>}>

Specifies the path to an Athena script (.tcl) file to load at start-up.
Any <tt -scenario> is loaded first.<p> 

<def {-web}>

Invokes the Arachne web servert at <tt -port>.  If this option is 
not specified, Arachne will halt immediately after loading the
<tt -scenario> and executing the <tt -script>.<p>

</deflist options>

<section restapi "RESTful API">

When Arachne is run with the <tt -port> command line option, it will 
initialize its RESTful HTTP interface, which can be accessed at 
<tt>https://127.0.0.1:<i portid></tt>.<p>  

By default, the HTTP interface can only be accessed from the local host.
If the <tt -public> option is given, then the HTTP interface
can be accessed from other hosts on the network.<p>

The set of URLs and HTTP operations supported by Arachne is <b TBD>, but
will certainly allow:<p>

<ul>
<li> Controlling scenario execution.
<li> Retrieving overall status information.
<li> Sending Athena executive scripts to Arachne.
<li> Sending Athena orders to Arachne (possibly as scripts)
<li> Requesting run-time results from Arachne
<li> Comparing two scenarios (or one scenario at different times) to
     determine significant deltas.
<li> Requesting explanations of significant deltas in terms of 
     chains of causality. 
</ul> 

Most requests will be GET requests; scripts will generally be sent using 
POST.  However, Arachne isn't terribly concerned about the request type.<p>

Information will be returned to the client as HTML or JSON text.  At
present, we assume that the front-end will do most of its own presentation,
and that the HTML will primarily be for debugging.  The return type will
be indicated by the file extension on the URL, ".html" or ".json".<p>

<section restapi.ref "API Reference">

<deflist urls>

<def {/scenario/index.{html,json}}>

Arachne will work with multiple Athena scenarios at one time.  This URL
returns an index of data about each scenario: the scenario's ID string,
state, current simulation time, and so forth.  The JSON output is formatted
as a list of objects.<p>

<def {/scenario/<i name>/order.{html,json}}>

These URLs are used to send an Athena order to a scenario whose ID is 
<i name>.  The order is sent as the URL query.  The query parameters
are the same as the Athena order parameters, plus the <tt order_> parameter
which specifies the order's name.<p>

The JSON result is a list of two or three elements.  The first element is a
code, "OK", "REJECT", or "ERROR".<p>

<ul>
<li>  If the code is "OK", the order was
      accepted; the second element is the order's result string, which is 
      typically empty.<p>

<li> If the code is "REJECT", the order was rejected.  The second 
     element is a JSON object with one field for each problem parameter
     in the order.  The field names are parameter names (or "*" for errors
     affecting the whole order); the field values are error messages for
     display to the user.<p>

<li> If the code is "ERROR", there was an unexpected error while executing
     the order.  The second element is an error message, and the third
     element is a stack trace.<p>
</ul>

<def {/scenario/<i name>/script.{html,json}}>

These URLs are used to send executive scripts to a scenario whose ID is
<i name>.  The HTML version presents a web form with a <tag textarea>
for entry of a script, and an "Execute" button.  Pressing "Execute" sends
the script, URL-encoded, as the value of the <tt script> query parameter
and reloads the page.  The script and the result value are displayed, and
the user can then enter and execute another script.<p>

The JSON version accepts the script as POST data in with a content-type of
<tt text/plain>.  (This can be changed, if desired.)  The script is 
executed, and the result returned to the client in JSON format.   

The JSON result is a list of two or three elements.  The first element is a
code, "OK" or "ERROR".<p>

<ul>
<li>  If the code is "OK", the executed successfully; the second element 
      is the script's result string.<p>

<li> If the code is "ERROR", there was an error while executing
     the script; this usually indicates a problem with the script itself.
     The second element is an error message, and the third
     element is a stack trace.<p>
</ul>


</deflist urls>

<section script "Athena Script Commands">

The RESTful interface allows executive scripts to be sent to a particular
scenario and executed by it; thus, the executive commands are part of the 
interface specification.  We already have high-quality documentation of
the executive commands as on-line help in the Athena Workbench; our 
plan for now is make this help database available through Arachne's
web interface.  The web developer can then invoke Arachne and browse
its help.<p>

</document>


