# -*-Tcl-*-
#-----------------------------------------------------------------------
# TITLE:
#    040-driver_magic.test
#
# AUTHOR:
#    Will Duquette
#
# DESCRIPTION:
#    driver_magic(sim) tests
#
#    This test suite tests that the rules fire when appropriate.
#
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# Initialize tcltest(n) and athena(1)

if {[lsearch [namespace children] ::tcltest] == -1} {
    source [file join [file dirname [file normalize [info script]]] ted.tcl]

    # Initialize tcltest(n), app_athena(n), et al.
    ted init $argv
}

#-----------------------------------------------------------------------
# Test Suite
#
# The tests run in a namespace so as not to interfere with other
# test suites.

namespace eval ::athena_test::tests:: {
    #-------------------------------------------------------------------
    # Set up the test environment

    # Import tcltest(n)
    namespace import ::tcltest::*

    # Fdicts

    set H1 {
        dtype   MAGIC
        mad_id  1
        atype   hrel
        mode    P
        mag     10.0
        f       SHIA
        g       BLUE
    }

    set H2 {
        dtype   MAGIC
        mad_id  1
        atype   hrel
        mode    T
        mag     1.0
        f       SHIA
        g       SUNN
    }


    set V1 {
        dtype   MAGIC
        mad_id  1
        atype   vrel
        mode    T
        mag     -10.0
        g       SHIA
        a       JOE
    }

    set S1 {
        dtype   MAGIC
        mad_id  1
        atype   sat
        mode    T
        mag     10.0
        g       SHIA
        c       AUT
    }

    set C1 {
        dtype   MAGIC
        mad_id  1
        atype   coop
        mode    T
        mag     10.0
        f       SHIA
        g       BLUE
    }

    # Define an htools buffer for tests
    htools ht

    # pprint text
    #
    # text  - block text
    #
    # Prints it so that it looks nice in a -result option.

    proc pprint {text} {
        return "\n[string trim $text]\n    "
    }

    # setup ?civgroup...?
    #
    # Sets up for tests.  Listed civgroups are given 0 population.
    
    proc setup {args} {
        # FIRST, other rule sets shouldn't muddy the waters.
        parm set dam.CONSUMP.active no
        parm set dam.PRESENCE.active no
        parm set dam.UNEMP.active no
        parm set dam.ENI.active no
        parm set dam.ENERGY.active no
        parm set dam.WATER.active no
        parm set dam.TRANSPORT.active no
        rdb eval {DELETE FROM drivers}
        rdb eval {DELETE FROM mads}

        # NEXT, create the entities
        ted create JOE BOB DAVE NB1 NB2 BLUE BRIT TAL SHIA SUNN KURD
        
        # NEXT, lock, so we can do magic inputs.
        ted lock

        # NEXT, Create a MAD for use; it will be MAD 1.
        ted order MAD:CREATE narrative "MAGIC Test" \
            cause UNIQUE s 1.0 p 0.2 q 0.1

        # NEXT, give each listed group zero population.
        foreach g $args {
            rdb eval {UPDATE demog_g SET population=0 WHERE g=$g}
        }
    }

    # Clean up after a test
    proc cleanup {} {
        ht clear
        ted cleanup
    }

    #-------------------------------------------------------------------
    # assess
    #
    # This also tests [ruleset].
    
    test assess-1.1 {Rule MAGIC-1-1 fires} -setup {
        setup
    } -body {
        driver::MAGIC assess $H1
        ted querylist {
            SELECT * FROM rule_firings
        }
    } -cleanup {
        cleanup
    } -result {
firing_id  1
t          0
driver_id  1000
ruleset    MAGIC
rule       MAGIC-1-1
fdict      dtype MAGIC mad_id 1 atype hrel mode P mag 10.0 f SHIA g BLUE
    }
    
    test assess-1.2 {Rule 1-1 inputs} -setup {
        setup
    } -body {
        driver::MAGIC assess $H1
        ted querylist {
            SELECT rule, atype, mode, f, g, mag, cause, s, p, q
            FROM rule_firings JOIN rule_inputs USING (firing_id)
        }
    } -cleanup {
        cleanup
    } -result {
rule   MAGIC-1-1
atype  hrel
mode   P
f      SHIA
g      BLUE
mag    10.0
cause  
s      
p      
q      
    }
    
    test assess-1.3 {Rule MAGIC-1-1 requires fpop > 0} -setup {
        setup SHIA
    } -body {
        driver::MAGIC assess $H2
        rdb eval {
            SELECT count(*) FROM rule_firings
        }
    } -cleanup {
        cleanup
    } -result {0}
    
    test assess-1.4 {Rule MAGIC-1-1 requires gpop > 0} -setup {
        setup SUNN
    } -body {
        driver::MAGIC assess $H2
        rdb eval {
            SELECT count(*) FROM rule_firings
        }
    } -cleanup {
        cleanup
    } -result {0}
    
    test assess-2.1 {Rule 2-1 fires} -setup {
        setup
    } -body {
        driver::MAGIC assess $V1
        ted querylist {
            SELECT * FROM rule_firings
        }
    } -cleanup {
        cleanup
    } -result {
firing_id  1
t          0
driver_id  1000
ruleset    MAGIC
rule       MAGIC-2-1
fdict      dtype MAGIC mad_id 1 atype vrel mode T mag -10.0 g SHIA a JOE
    }
    
    test assess-2.2 {Rule 2-1 inputs} -setup {
        setup
    } -body {
        driver::MAGIC assess $V1
        ted querylist {
            SELECT rule, atype, mode, g, a, mag, cause, s, p, q
            FROM rule_firings JOIN rule_inputs USING (firing_id)
        }
    } -cleanup {
        cleanup
    } -result {
rule   MAGIC-2-1
atype  vrel
mode   T
g      SHIA
a      JOE
mag    -10.0
cause  
s      
p      
q      
    }
    
    test assess-2.3 {Rule MAGIC-2-1 requires gpop > 0} -setup {
        setup SHIA
    } -body {
        driver::MAGIC assess $V1
        rdb eval {
            SELECT count(*) FROM rule_firings
        }
    } -cleanup {
        cleanup
    } -result {0}
    
    test assess-3.1 {Rule 3-1 fires} -setup {
        setup
    } -body {
        driver::MAGIC assess $S1
        ted querylist {
            SELECT * FROM rule_firings
        }
    } -cleanup {
        cleanup
    } -result {
firing_id  1
t          0
driver_id  1000
ruleset    MAGIC
rule       MAGIC-3-1
fdict      dtype MAGIC mad_id 1 atype sat mode T mag 10.0 g SHIA c AUT
    }
    
    test assess-3.2 {Rule 3-1 inputs} -setup {
        setup
    } -body {
        driver::MAGIC assess $S1
        ted querylist {
            SELECT rule, atype, mode, g, c, mag, cause, s, p, q
            FROM rule_firings JOIN rule_inputs USING (firing_id)
        }
    } -cleanup {
        cleanup
    } -result {
rule   MAGIC-3-1
atype  sat
mode   T
g      SHIA
c      AUT
mag    10.0
cause  
s      1.0
p      0.2
q      0.1
    }

    test assess-3.3 {Rule MAGIC-3-1 requires gpop > 0} -setup {
        setup SHIA
    } -body {
        driver::MAGIC assess $S1
        rdb eval {
            SELECT count(*) FROM rule_firings
        }
    } -cleanup {
        cleanup
    } -result {0}
    
    test assess-4.1 {Rule 4-1 fires} -setup {
        setup
    } -body {
        driver::MAGIC assess $C1
        ted querylist {
            SELECT * FROM rule_firings
        }
    } -cleanup {
        cleanup
    } -result {
firing_id  1
t          0
driver_id  1000
ruleset    MAGIC
rule       MAGIC-4-1
fdict      dtype MAGIC mad_id 1 atype coop mode T mag 10.0 f SHIA g BLUE
    }
    
    test assess-4.2 {Rule 4-1 inputs} -setup {
        setup
    } -body {
        driver::MAGIC assess $C1
        ted querylist {
            SELECT rule, atype, mode, f, g, mag, cause, s, p, q
            FROM rule_firings JOIN rule_inputs USING (firing_id)
        }
    } -cleanup {
        cleanup
    } -result {
rule   MAGIC-4-1
atype  coop
mode   T
f      SHIA
g      BLUE
mag    10.0
cause  
s      1.0
p      0.2
q      0.1
    }

    test assess-4.3 {Rule MAGIC-4-1 requires fpop > 0} -setup {
        setup SHIA
    } -body {
        driver::MAGIC assess $C1
        rdb eval {
            SELECT count(*) FROM rule_firings
        }
    } -cleanup {
        cleanup
    } -result {0}
  
    #-------------------------------------------------------------------
    # sigline

    test sigline-1.1 {sigline output} -setup {
        setup
    } -body {
        driver::MAGIC sigline 1
    } -cleanup {
        cleanup
    } -result {MAGIC Test}
         


    #-------------------------------------------------------------------
    # narrative

    test narrative-1.1 {narrative output} -setup {
        setup
    } -body {
        driver::MAGIC narrative {
            dtype   MAGIC
            mad_id  1
            atype   sat
            mode    T
            mag     10.0
            g       SHIA
            c       AUT
        } 
    } -cleanup {
        cleanup
    } -result {MAD {mad:1} sat T SHIA,AUT 10.0}
         
    #-------------------------------------------------------------------
    # detail

    test detail-1.1 {MAGIC detail, controller exists} -setup {
        setup
    } -body {
        driver::MAGIC detail {
            dtype   MAGIC
            mad_id  1
            atype   sat
            mode    T
            mag     10.0
            g       SHIA
            c       AUT
        } [namespace current]::ht

        pprint [ht get] 
    } -cleanup {
        cleanup
    } -result {
<a href="my://app/mad/1">MAD 1</a>: MAGIC Test<p>
    }
    
    
    cleanupTests
}

namespace delete ::athena_test::tests::


